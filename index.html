<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Cash Cleaner Online - Free ASMR Washing Simulator (Unblocked)</title>
    <meta name="description" content="Play the viral Cash Cleaner game online for free. Satisfying ASMR money washing simulator. No download required. Unblocked for school/work.">
    <meta name="keywords" content="cash cleaner, money washing game, asmr simulator, unblocked games, cash cleaner online, money cleaner, satisfying game, asmr game">
    <meta name="author" content="Cash Cleaner Online">
    <meta property="og:title" content="Cash Cleaner Online - Free ASMR Washing Simulator">
    <meta property="og:description" content="Experience the satisfying ASMR of cleaning dirty cash. Play now - no download needed!">
    <meta property="og:type" content="website">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Fullscreen Canvas */
        canvas {
            position: fixed;
            inset: 0;
            display: block;
        }

        /* Score Board HUD */
        #score-board {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 15px 25px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            line-height: 1.4;
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            z-index: 1000;
            user-select: none;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #score-board .label {
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            margin-bottom: 5px;
        }

        /* Debug HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            z-index: 1000;
            user-select: none;
        }

        #hud div {
            margin: 2px 0;
        }

        /* SEO Overlay */
        #seoOverlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            max-height: 50vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: #ffffff;
            z-index: 900;
            transition: transform 0.3s ease;
        }

        #seoOverlay.hidden {
            transform: translateY(100%);
        }

        #seoToggle {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            z-index: 901;
            user-select: none;
        }

        #seoToggle:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        #content {
            width: 100%;
            max-width: 900px;
            padding: 40px 20px;
            margin: 0 auto;
            line-height: 1.8;
            user-select: text;
        }

        #content h2 {
            color: #00ff88;
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #content h2:first-child {
            margin-top: 0;
        }

        #content p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 15px;
            margin-bottom: 15px;
            text-align: justify;
        }

        #adBottom {
            text-align: center;
            padding: 30px 0;
            background: rgba(0, 0, 0, 0.8);
        }

        footer {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        footer a {
            color: #00ff88;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Collect Feedback */
        #collectFeedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #00ff88, #00cc66);
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #111;
            z-index: 2000;
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        #collectFeedback.show {
            transform: translate(-50%, -50%) scale(1);
        }

        @media (max-width: 768px) {
            #content {
                padding: 30px 15px;
            }
            #content h2 {
                font-size: 20px;
            }
            #content p {
                font-size: 14px;
            }
            #hud {
                font-size: 10px;
                padding: 8px;
            }
            #score-board {
                font-size: 18px;
                padding: 12px 20px;
            }
            #score-board .label {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Score Board -->
    <div id="score-board">
        <div class="label">CLEANED</div>
        <div id="scoreAmount">$0</div>
    </div>

    <!-- Debug HUD -->
    <div id="hud">
        <div>FPS: <span id="fps">0</span></div>
        <div>Collected: <span id="collectedCount">0</span></div>
        <div>Camera: <span id="camPos">0,0,0</span></div>
        <div>Exposure: <span id="exposure">1.25</span></div>
        <div style="margin-top:8px;color:#888">H: Info | L/K: Exposure | R: Reset Cam</div>
    </div>

    <!-- Collect Feedback -->
    <div id="collectFeedback">+$100</div>

    <!-- SEO Overlay Toggle -->
    <div id="seoToggle" onclick="toggleSEO()">Press H for Info</div>

    <!-- SEO Content Overlay -->
    <div id="seoOverlay" class="hidden">
        <section id="content">
            <h2>What is Cash Cleaner Online?</h2>
            <p>Cash Cleaner Online is a free-to-play browser-based cleaning simulator that brings the viral ASMR satisfaction of power washing directly to your screen. The game recreates the oddly satisfying experience of using a high-pressure washer to clean dirty money, gold bars, and credit cards. Unlike traditional mobile apps that require downloads and installations, this web version is instantly accessible from any device with a browser.</p>
            <p>The gameplay is elegantly simple yet deeply engaging. Players are presented with various valuable items covered in layers of realistic dirt and grime. Using your mouse or finger as a virtual pressure washer, you drag across the screen to blast away the accumulated muck. As you clean, water spray particles animate in real-time, creating a mesmerizing visual effect that mimics actual cleaning physics. The dirt erodes gradually under your cursor, revealing the pristine surface beneath.</p>
            <p>What sets Cash Cleaner Online apart is its progressive reward system. Each successfully cleaned item grants you virtual earnings - from $100 for standard bills to $1000 for platinum cards. The game continuously generates new dirty items to maintain an endless loop of satisfaction. This creates what psychologists call a "flow state" - that perfect balance between challenge and reward that keeps players engaged for extended sessions. The visual feedback is immediate and gratifying, with confetti explosions and glowing animations celebrating each completed cleaning.</p>
            <p>The game has gained massive popularity in online communities, schools, and workplaces because it's completely unblocked and requires no permissions. It's the perfect stress-relief tool during breaks, offering a few minutes of mindless zen without any learning curve or complex mechanics. The dark aesthetic makes the bright money pop visually, creating strong contrast that's both aesthetically pleasing and easy on the eyes during extended play sessions.</p>

            <h2>Why Cash Cleaning Games Are So Satisfying</h2>
            <p>The phenomenon of cleaning games taps into deep psychological mechanisms that explain why millions of players find them irresistibly satisfying. At its core, the appeal lies in our brain's reward system responding to visible progress and completion. When you see dirt disappearing under your cursor in real-time, your brain releases small doses of dopamine - the same neurotransmitter associated with achievement and pleasure. This is why power washing videos have garnered billions of views across social media platforms.</p>
            <p>ASMR (Autonomous Sensory Meridian Response) plays a significant role in the appeal of cleaning simulators. While Cash Cleaner Online doesn't include sound, the visual ASMR effect is equally powerful. The gradual transformation from dirty to clean creates a sense of order emerging from chaos, which resonates with our innate desire for control and organization. This visual satisfaction is amplified by the particle effects that simulate water spray, triggering the same neural pathways activated by watching real cleaning processes.</p>
            <p>From a cognitive psychology perspective, these games offer what researchers call "productive procrastination." They provide a sense of accomplishment without real-world consequences or stress. In today's high-pressure environment where complex tasks can feel overwhelming, the simple binary outcome of dirty-to-clean offers clarity and immediate gratification. Each swipe produces visible results, creating a micro-achievement loop that's incredibly addictive.</p>
            <p>The repetitive nature of the cleaning motion also has meditative qualities. Similar to how coloring books have become popular stress-relief tools for adults, the rhythmic dragging motion required in Cash Cleaner Online creates a focused, almost trance-like state. This repetition can lower cortisol levels and reduce anxiety, making these games unexpectedly therapeutic. Players report feeling calmer and more centered after playing, which explains why cleaning simulators have become popular during work breaks and before sleep.</p>

            <h2>How to Play Cash Cleaner Online</h2>
            <p>Getting started with Cash Cleaner Online is incredibly straightforward - there's virtually no learning curve. Simply load the page and you'll immediately see a dirty bill displayed in the center of your screen. The dirt layer is represented by a dark, gritty overlay that completely obscures the clean money beneath.</p>
            <p>On desktop computers, use your mouse to click and drag across the dirty surface. On mobile devices and tablets, use your finger to swipe across the screen. As you move your cursor or finger, the high-pressure washer effect kicks in, erasing the dirt layer and revealing the pristine surface underneath. The larger your movements, the faster you'll clean. The game tracks your progress in real-time via a progress bar at the top of the screen, showing the percentage of dirt removed.</p>
            <p>Your goal is to reach 95% cleanliness. Once you hit this threshold, the game celebrates your achievement with a spectacular confetti explosion and displays your earned reward. After a brief celebration animation, a new dirty item automatically appears - either another dollar bill, a gold bar, or a platinum credit card. Each item type has slightly different textures and colors, keeping the visual experience fresh.</p>
            <p>The beauty of Cash Cleaner Online is that there's no wrong way to play. Some players prefer methodical horizontal strokes, others use circular motions, and some just frantically scrub random areas. All approaches work equally well. The game is designed for instant satisfaction - you can complete a single cleaning cycle in under 60 seconds, making it perfect for quick breaks or extended relaxation sessions alike.</p>

            <h2>Is Cash Cleaner Online Free?</h2>
            <p>Yes, Cash Cleaner Online is completely free to play with absolutely no hidden costs or microtransactions. There's no premium version, no in-app purchases, no subscription fees, and no advertisements interrupting your gameplay. The game was designed as a pure entertainment experience without monetization mechanics that would detract from the core satisfaction loop.</p>
            <p>You don't need to create an account, provide an email address, or download any software. Simply visit the website and start playing immediately. This accessibility is intentional - the goal is to provide instant stress relief without any barriers to entry. The game works on all modern browsers including Chrome, Firefox, Safari, and Edge, across all device types from smartphones to desktop computers.</p>
            <p>Because the game runs entirely in your browser using HTML5 technology, there are no storage requirements on your device and no permissions needed. Your progress isn't saved between sessions, which is actually a feature rather than a limitation - it means each visit offers a fresh start without the pressure of maintaining streaks or achievements. This design philosophy keeps the experience pure and meditative, focused solely on the immediate satisfaction of cleaning rather than long-term progression systems that can create addictive patterns.</p>
            <p>The game is also completely unblocked, meaning it works on school networks, office wifi, and other restricted internet connections that typically block gaming sites. This has made Cash Cleaner Online particularly popular among students looking for quick study breaks and office workers seeking momentary stress relief during busy workdays.</p>
        </section>

        <div id="adBottom">
            <script>
              atOptions = {
                'key' : 'ec8c5f314722aa8c54e18afcf25d60c7',
                'format' : 'iframe',
                'height' : 90,
                'width' : 728,
                'params' : {}
              };
            </script>
            <script src="https://offeringmakeup.com/ec8c5f314722aa8c54e18afcf25d60c7/invoke.js"></script>
        </div>

        <footer>
            <a href="/privacy.html">Privacy Policy</a> |
            <a href="/terms.html">Terms of Service</a> |
            <a href="/about.html">About Us</a> |
            <a href="/contact.html">Contact</a>
        </footer>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';

        // ===== Global State =====
        let scene, camera, renderer, controls;
        let bills = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-999, -999); // Initialize off-screen
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        // Interaction state
        let hoveredBill = null;
        let totalScore = 0;
        let collectedCount = 0;

        // Audio system
        let audioContext;
        let isAudioInitialized = false;

        // Scene dimensions (computed from geometry)
        const roomDimensions = { width: 12, height: 6, depth: 12 };
        const tableDimensions = { width: 3, height: 0.1, depth: 2, posY: 1 };
        const floorY = 0;
        const collisionMargin = 0.3;

        // ===== Init =====
        function init() {
            createScene();
            createLights();
            createRoom();
            createTable();
            createProps();
            loadBillTexture();
            bindInput();
            initAudio();
            animate();
        }

        // ===== Audio System =====
        function initAudio() {
            // Lazy init on first user interaction
            document.addEventListener('click', () => {
                if (!isAudioInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    isAudioInitialized = true;
                    console.log('Audio initialized');
                }
            }, { once: true });
        }

        function playCollectSound() {
            if (!isAudioInitialized) return;
            
            // Create pleasant collection sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // ===== Scene Setup =====
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 8, 20);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 4, 5);
            camera.lookAt(0, 1.1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.physicallyCorrectLights = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.enablePan = false;
            controls.rotateSpeed = 0.9;
            controls.zoomSpeed = 0.9;
            controls.minDistance = 2.6;
            controls.maxDistance = 7.0;
            controls.minPolarAngle = Math.PI * 0.18;
            controls.maxPolarAngle = Math.PI * 0.48;
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        // ===== Lights =====
        function createLights() {
            // Ambient light - cool tone, weak
            const ambientLight = new THREE.AmbientLight(0x6688bb, 0.3);
            scene.add(ambientLight);

            // Hemisphere light - cool top, warm ground
            const hemiLight = new THREE.HemisphereLight(0x5577cc, 0x664422, 0.5);
            scene.add(hemiLight);

            // Main spotlight from ceiling
            const spotLight = new THREE.SpotLight(0xfffff0, 120);
            spotLight.position.set(0, 5.5, 0.5);
            spotLight.target.position.set(0, 1, 0);
            spotLight.angle = Math.PI / 4.5;
            spotLight.penumbra = 0.4;
            spotLight.decay = 2;
            spotLight.distance = 10;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 10;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);
            scene.add(spotLight.target);

            // RectAreaLight - key fill light from side-front
            const rectLight = new THREE.RectAreaLight(0xffffff, 4, 3, 2);
            rectLight.position.set(2, 2, 3);
            rectLight.lookAt(0, 1, 0);
            scene.add(rectLight);

            // Additional soft fill from opposite side
            const fillLight = new THREE.PointLight(0xaabbcc, 0.8, 8);
            fillLight.position.set(-2, 2.5, 2);
            scene.add(fillLight);
        }

        // ===== Room =====
        function createRoom() {
            // Inverted box for basement room - backside normals
            const roomGeo = new THREE.BoxGeometry(12, 6, 12);
            const roomMat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                side: THREE.BackSide,
                roughness: 0.9,
                metalness: 0.05
            });
            const room = new THREE.Mesh(roomGeo, roomMat);
            room.position.y = 3;
            room.receiveShadow = true;
            scene.add(room);

            // Floor with slight reflectivity
            const floorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x424242,
                roughness: 0.7,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        // ===== Table =====
        function createTable() {
            // Wood material with procedural variation
            const tableMat = new THREE.MeshStandardMaterial({
                color: 0x5a3825,
                roughness: 0.7,
                metalness: 0.05,
                roughnessMap: createWoodRoughnessMap()
            });

            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 2),
                tableMat
            );
            tableTop.position.set(0, 1, 0);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            scene.add(tableTop);

            const legGeo = new THREE.BoxGeometry(0.1, 0.9, 0.1);
            const positions = [
                [-1.3, 0.45, -0.85],
                [1.3, 0.45, -0.85],
                [-1.3, 0.45, 0.85],
                [1.3, 0.45, 0.85]
            ];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });
        }

        function createWoodRoughnessMap() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base wood color with grain
            for (let y = 0; y < size; y++) {
                const grainIntensity = Math.sin(y * 0.1) * 20 + 128;
                ctx.fillStyle = `rgb(${grainIntensity},${grainIntensity},${grainIntensity})`;
                ctx.fillRect(0, y, size, 1);
            }
            
            // Add noise variation
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = data[i];
                data[i+2] = data[i];
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            return texture;
        }

        // ===== Room Props =====
        function createProps() {
            // Crate in corner
            const crateMat = new THREE.MeshStandardMaterial({
                color: 0x5a4a3a,
                roughness: 0.9,
                metalness: 0.0
            });
            const crate = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), crateMat);
            crate.position.set(-4, 0.4, -4);
            crate.rotation.y = 0.3;
            crate.castShadow = true;
            crate.receiveShadow = true;
            scene.add(crate);

            // Pipes along wall
            const pipeMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.4,
                metalness: 0.6
            });
            const pipe1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4, 8), pipeMat);
            pipe1.position.set(-5.9, 1.5, 0);
            pipe1.rotation.z = Math.PI / 2;
            pipe1.castShadow = true;
            scene.add(pipe1);

            // Neon strip light
            const neonGeo = new THREE.BoxGeometry(2, 0.05, 0.05);
            const neonMat = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 2,
                roughness: 0.2,
                metalness: 0.8
            });
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.position.set(3, 2.5, -5.9);
            scene.add(neon);

            // Add small point light for neon
            const neonLight = new THREE.PointLight(0x00ff88, 0.5, 3);
            neonLight.position.copy(neon.position);
            scene.add(neonLight);
        }

        // ===== Money System =====
        let billTexture = null;

        function loadBillTexture() {
            const loader = new THREE.TextureLoader();
            
            // Try to load dollar bill texture
            loader.load(
                'https://upload.wikimedia.org/wikipedia/commons/7/7b/United_States_one_dollar_bill_obverse.jpg',
                (texture) => {
                    console.log('Bill texture loaded successfully');
                    billTexture = texture;
                    createMoney();
                },
                undefined,
                (error) => {
                    console.warn('Failed to load bill texture, using fallback color', error);
                    billTexture = null; // Use fallback color
                    createMoney();
                }
            );
        }

        function createMoney() {
            const billGeo = new THREE.PlaneGeometry(0.3, 0.15); // 2:1 ratio
            const billCount = 50;

            for (let i = 0; i < billCount; i++) {
                // Create material with texture or fallback color
                const billMat = new THREE.MeshStandardMaterial({
                    color: billTexture ? 0xffffff : 0x85bb65, // White if textured, green fallback
                    map: billTexture,
                    roughness: 0.6,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    emissive: 0x000000,
                    emissiveIntensity: 0
                });

                const bill = new THREE.Mesh(billGeo, billMat);
                
                // Random placement on table surface
                const randomX = (Math.random() - 0.5) * 2.4;
                const randomZ = (Math.random() - 0.5) * 1.6;
                const randomYOffset = Math.random() * 0.01; // Prevent Z-fighting
                
                bill.position.set(
                    randomX,
                    1.055 + randomYOffset,
                    randomZ
                );
                
                // Rotate to lay flat on table, with random rotation around Y axis
                bill.rotation.set(
                    -Math.PI / 2, // Lay flat on XZ plane
                    Math.random() * Math.PI * 2, // Random rotation around Y (up) axis
                    0
                );
                
                bill.castShadow = true;
                bill.receiveShadow = true;
                
                // Store original state for interaction
                bill.userData = {
                    id: i,
                    baseY: bill.position.y,
                    baseEmissive: 0,
                    isHovered: false,
                    value: 100
                };
                
                bills.push(bill);
                scene.add(bill);
            }
            
            console.log(`Created ${billCount} bills on table`);
        }

        // ===== Interaction System =====
        function updateInteraction() {
            // Cast ray from camera through mouse position
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bills, false);
            
            // Reset previously hovered bill
            if (hoveredBill && (intersects.length === 0 || intersects[0].object !== hoveredBill)) {
                hoveredBill.position.y = hoveredBill.userData.baseY;
                hoveredBill.material.emissive.setHex(0x000000);
                hoveredBill.material.emissiveIntensity = 0;
                hoveredBill.userData.isHovered = false;
                hoveredBill = null;
            }
            
            // Apply hover effect to current bill
            if (intersects.length > 0) {
                const bill = intersects[0].object;
                if (bill !== hoveredBill) {
                    hoveredBill = bill;
                    hoveredBill.userData.isHovered = true;
                }
                
                // Hover effects
                hoveredBill.position.y = hoveredBill.userData.baseY + 0.02; // Lift up
                hoveredBill.material.emissive.setHex(0x00ff88); // Glow green
                hoveredBill.material.emissiveIntensity = 0.3;
            }
        }

        function collectBill(bill) {
            if (!bill) return;
            
            // Animate bill collection
            const startScale = { x: 1, y: 1, z: 1 };
            const duration = 300;
            const startTime = performance.now();
            
            function animateCollect() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Scale down animation
                const scale = 1 - progress;
                bill.scale.set(scale, scale, scale);
                
                // Spin animation
                bill.rotation.z += 0.2;
                
                if (progress < 1) {
                    requestAnimationFrame(animateCollect);
                } else {
                    // Remove from scene and array
                    scene.remove(bill);
                    bills = bills.filter(b => b !== bill);
                    
                    // Dispose resources
                    if (bill.geometry) bill.geometry.dispose();
                    if (bill.material) bill.material.dispose();
                    
                    console.log(`Bill collected! Remaining: ${bills.length}`);
                }
            }
            
            animateCollect();
            
            // Update score
            const value = bill.userData.value || 100;
            totalScore += value;
            collectedCount++;
            updateScoreBoard();
            showCollectFeedback(value);
            playCollectSound();
        }

        function updateScoreBoard() {
            document.getElementById('scoreAmount').textContent = '$' + totalScore;
            document.getElementById('collectedCount').textContent = collectedCount;
        }

        function showCollectFeedback(value) {
            const feedback = document.getElementById('collectFeedback');
            feedback.textContent = '+$' + value;
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 500);
        }

        // ===== Input =====
        function bindInput() {
            window.addEventListener('resize', onResize);
            window.addEventListener('click', onClick);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('mousemove', onMouseMove);
        }

        function onMouseMove(event) {
            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // ===== Camera Clamping =====
        function clampCamera() {
            const pos = camera.position;
            
            // 1. Floor constraint
            if (pos.y < floorY + collisionMargin) {
                pos.y = floorY + collisionMargin;
            }
            
            // 2. Room boundary constraints
            const roomHalfX = roomDimensions.width / 2 - collisionMargin;
            const roomHalfZ = roomDimensions.depth / 2 - collisionMargin;
            
            pos.x = THREE.MathUtils.clamp(pos.x, -roomHalfX, roomHalfX);
            pos.z = THREE.MathUtils.clamp(pos.z, -roomHalfZ, roomHalfZ);
            
            // 3. Table collision (Box3 check)
            const tableBox = new THREE.Box3(
                new THREE.Vector3(
                    -tableDimensions.width / 2 - collisionMargin,
                    tableDimensions.posY - tableDimensions.height / 2 - collisionMargin,
                    -tableDimensions.depth / 2 - collisionMargin
                ),
                new THREE.Vector3(
                    tableDimensions.width / 2 + collisionMargin,
                    tableDimensions.posY + tableDimensions.height / 2 + collisionMargin,
                    tableDimensions.depth / 2 + collisionMargin
                )
            );
            
            if (tableBox.containsPoint(pos)) {
                // Push camera out from table center
                const tableCenter = new THREE.Vector3(0, tableDimensions.posY, 0);
                const pushDir = pos.clone().sub(tableCenter).normalize();
                
                // Find closest point on box boundary
                const closestPoint = tableBox.clampPoint(pos, new THREE.Vector3());
                const pushDistance = collisionMargin * 1.5;
                
                pos.copy(closestPoint).add(pushDir.multiplyScalar(pushDistance));
                
                // Update controls distance if needed
                const distToTarget = pos.distanceTo(controls.target);
                if (distToTarget < controls.minDistance) {
                    controls.minDistance = distToTarget + 0.1;
                }
            }
        }

        function onClick(event) {
            // Collect hovered bill on click
            if (hoveredBill) {
                collectBill(hoveredBill);
                hoveredBill = null;
            }
        }

        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'h':
                    toggleSEO();
                    break;
                case 'l':
                    renderer.toneMappingExposure = Math.min(3, renderer.toneMappingExposure + 0.1);
                    updateHUD();
                    break;
                case 'k':
                    renderer.toneMappingExposure = Math.max(0.5, renderer.toneMappingExposure - 0.1);
                    updateHUD();
                    break;
                case 'r':
                    resetCamera();
                    break;
            }
        }

        function resetCamera() {
            camera.position.set(0, 4, 5);
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== Animation Loop =====
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = now - lastTime;
            lastTime = now;

            frameCount++;
            fpsTime += delta;
            if (fpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // Update interaction system
            updateInteraction();

            controls.update();
            clampCamera(); // Prevent camera clipping through objects
            updateHUD();
            renderer.render(scene, camera);
        }

        // ===== HUD =====
        function updateHUD() {
            const pos = camera.position;
            document.getElementById('camPos').textContent = 
                `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;
            document.getElementById('exposure').textContent = 
                renderer.toneMappingExposure.toFixed(2);
        }

        // ===== SEO Toggle =====
        window.toggleSEO = function() {
            document.getElementById('seoOverlay').classList.toggle('hidden');
        }

        // Start
        init();
    </script>

    <script src="https://offeringmakeup.com/a0/2d/50/a02d50405ef0bdf0d4243259c7266ce6.js"></script>
</body>
</html>
