<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Cash Cleaner Online - Free ASMR Washing Simulator (Unblocked)</title>
    <meta name="description" content="Play the viral Cash Cleaner game online for free. Satisfying ASMR money washing simulator. No download required. Unblocked for school/work.">
    <meta name="keywords" content="cash cleaner, money washing game, asmr simulator, unblocked games, cash cleaner online, money cleaner, satisfying game, asmr game">
    <meta name="author" content="Cash Cleaner Online">
    <meta property="og:title" content="Cash Cleaner Online - Free ASMR Washing Simulator">
    <meta property="og:description" content="Experience the satisfying ASMR of cleaning dirty cash. Play now - no download needed!">
    <meta property="og:type" content="website">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Fullscreen Canvas */
        canvas {
            position: fixed;
            inset: 0;
            display: block;
        }

        /* Debug HUD */
        #hud {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            z-index: 1000;
            user-select: none;
        }

        #hud div {
            margin: 2px 0;
        }

        /* SEO Overlay */
        #seoOverlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            max-height: 50vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: #ffffff;
            z-index: 900;
            transition: transform 0.3s ease;
        }

        #seoOverlay.hidden {
            transform: translateY(100%);
        }

        #seoToggle {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            z-index: 901;
            user-select: none;
        }

        #seoToggle:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        #content {
            width: 100%;
            max-width: 900px;
            padding: 40px 20px;
            margin: 0 auto;
            line-height: 1.8;
            user-select: text;
        }

        #content h2 {
            color: #00ff88;
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #content h2:first-child {
            margin-top: 0;
        }

        #content p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 15px;
            margin-bottom: 15px;
            text-align: justify;
        }

        #adBottom {
            text-align: center;
            padding: 30px 0;
            background: rgba(0, 0, 0, 0.8);
        }

        footer {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        footer a {
            color: #00ff88;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Cleaning Progress UI */
        #cleaningUI {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            width: 180px;
        }

        #cleaningUI h3 {
            color: #00ff88;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }

        #progressBar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        #progressFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            transition: width 0.2s;
        }

        #progressText {
            text-align: center;
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #brushInfo {
            font-size: 11px;
            color: #888;
            text-align: center;
        }

        #cleanedNotice {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #00ff88, #00cc66);
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #111;
            z-index: 2000;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #cleanedNotice.show {
            transform: translate(-50%, -50%) scale(1);
        }

        @media (max-width: 768px) {
            #content {
                padding: 30px 15px;
            }
            #content h2 {
                font-size: 20px;
            }
            #content p {
                font-size: 14px;
            }
            #hud {
                font-size: 10px;
                padding: 8px;
            }
            #cleaningUI {
                width: 140px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Debug HUD -->
    <div id="hud">
        <div>FPS: <span id="fps">0</span></div>
        <div>Cleaned: <span id="cleanedCount">0</span></div>
        <div>Camera: <span id="camPos">0,0,0</span></div>
        <div>Exposure: <span id="exposure">1.25</span></div>
        <div>Brush: <span id="brushSize">25</span>px</div>
        <div style="margin-top:8px;color:#888">H: Info | [/]: Brush | Shift: Fine</div>
    </div>

    <!-- Cleaning Progress UI -->
    <div id="cleaningUI">
        <h3>CLEANING PROGRESS</h3>
        <div id="progressText">0%</div>
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        <div id="brushInfo">Hold & Drag to Clean</div>
    </div>

    <!-- Cleaned Notice -->
    <div id="cleanedNotice">CLEANED! âœ¨</div>

    <!-- SEO Overlay Toggle -->
    <div id="seoToggle" onclick="toggleSEO()">Press H for Info</div>

    <!-- SEO Content Overlay -->
    <div id="seoOverlay" class="hidden">
        <section id="content">
            <h2>What is Cash Cleaner Online?</h2>
            <p>Cash Cleaner Online is a free-to-play browser-based cleaning simulator that brings the viral ASMR satisfaction of power washing directly to your screen. The game recreates the oddly satisfying experience of using a high-pressure washer to clean dirty money, gold bars, and credit cards. Unlike traditional mobile apps that require downloads and installations, this web version is instantly accessible from any device with a browser.</p>
            <p>The gameplay is elegantly simple yet deeply engaging. Players are presented with various valuable items covered in layers of realistic dirt and grime. Using your mouse or finger as a virtual pressure washer, you drag across the screen to blast away the accumulated muck. As you clean, water spray particles animate in real-time, creating a mesmerizing visual effect that mimics actual cleaning physics. The dirt erodes gradually under your cursor, revealing the pristine surface beneath.</p>
            <p>What sets Cash Cleaner Online apart is its progressive reward system. Each successfully cleaned item grants you virtual earnings - from $100 for standard bills to $1000 for platinum cards. The game continuously generates new dirty items to maintain an endless loop of satisfaction. This creates what psychologists call a "flow state" - that perfect balance between challenge and reward that keeps players engaged for extended sessions. The visual feedback is immediate and gratifying, with confetti explosions and glowing animations celebrating each completed cleaning.</p>
            <p>The game has gained massive popularity in online communities, schools, and workplaces because it's completely unblocked and requires no permissions. It's the perfect stress-relief tool during breaks, offering a few minutes of mindless zen without any learning curve or complex mechanics. The dark aesthetic makes the bright money pop visually, creating strong contrast that's both aesthetically pleasing and easy on the eyes during extended play sessions.</p>

            <h2>Why Cash Cleaning Games Are So Satisfying</h2>
            <p>The phenomenon of cleaning games taps into deep psychological mechanisms that explain why millions of players find them irresistibly satisfying. At its core, the appeal lies in our brain's reward system responding to visible progress and completion. When you see dirt disappearing under your cursor in real-time, your brain releases small doses of dopamine - the same neurotransmitter associated with achievement and pleasure. This is why power washing videos have garnered billions of views across social media platforms.</p>
            <p>ASMR (Autonomous Sensory Meridian Response) plays a significant role in the appeal of cleaning simulators. While Cash Cleaner Online doesn't include sound, the visual ASMR effect is equally powerful. The gradual transformation from dirty to clean creates a sense of order emerging from chaos, which resonates with our innate desire for control and organization. This visual satisfaction is amplified by the particle effects that simulate water spray, triggering the same neural pathways activated by watching real cleaning processes.</p>
            <p>From a cognitive psychology perspective, these games offer what researchers call "productive procrastination." They provide a sense of accomplishment without real-world consequences or stress. In today's high-pressure environment where complex tasks can feel overwhelming, the simple binary outcome of dirty-to-clean offers clarity and immediate gratification. Each swipe produces visible results, creating a micro-achievement loop that's incredibly addictive.</p>
            <p>The repetitive nature of the cleaning motion also has meditative qualities. Similar to how coloring books have become popular stress-relief tools for adults, the rhythmic dragging motion required in Cash Cleaner Online creates a focused, almost trance-like state. This repetition can lower cortisol levels and reduce anxiety, making these games unexpectedly therapeutic. Players report feeling calmer and more centered after playing, which explains why cleaning simulators have become popular during work breaks and before sleep.</p>

            <h2>How to Play Cash Cleaner Online</h2>
            <p>Getting started with Cash Cleaner Online is incredibly straightforward - there's virtually no learning curve. Simply load the page and you'll immediately see a dirty bill displayed in the center of your screen. The dirt layer is represented by a dark, gritty overlay that completely obscures the clean money beneath.</p>
            <p>On desktop computers, use your mouse to click and drag across the dirty surface. On mobile devices and tablets, use your finger to swipe across the screen. As you move your cursor or finger, the high-pressure washer effect kicks in, erasing the dirt layer and revealing the pristine surface underneath. The larger your movements, the faster you'll clean. The game tracks your progress in real-time via a progress bar at the top of the screen, showing the percentage of dirt removed.</p>
            <p>Your goal is to reach 95% cleanliness. Once you hit this threshold, the game celebrates your achievement with a spectacular confetti explosion and displays your earned reward. After a brief celebration animation, a new dirty item automatically appears - either another dollar bill, a gold bar, or a platinum credit card. Each item type has slightly different textures and colors, keeping the visual experience fresh.</p>
            <p>The beauty of Cash Cleaner Online is that there's no wrong way to play. Some players prefer methodical horizontal strokes, others use circular motions, and some just frantically scrub random areas. All approaches work equally well. The game is designed for instant satisfaction - you can complete a single cleaning cycle in under 60 seconds, making it perfect for quick breaks or extended relaxation sessions alike.</p>

            <h2>Is Cash Cleaner Online Free?</h2>
            <p>Yes, Cash Cleaner Online is completely free to play with absolutely no hidden costs or microtransactions. There's no premium version, no in-app purchases, no subscription fees, and no advertisements interrupting your gameplay. The game was designed as a pure entertainment experience without monetization mechanics that would detract from the core satisfaction loop.</p>
            <p>You don't need to create an account, provide an email address, or download any software. Simply visit the website and start playing immediately. This accessibility is intentional - the goal is to provide instant stress relief without any barriers to entry. The game works on all modern browsers including Chrome, Firefox, Safari, and Edge, across all device types from smartphones to desktop computers.</p>
            <p>Because the game runs entirely in your browser using HTML5 technology, there are no storage requirements on your device and no permissions needed. Your progress isn't saved between sessions, which is actually a feature rather than a limitation - it means each visit offers a fresh start without the pressure of maintaining streaks or achievements. This design philosophy keeps the experience pure and meditative, focused solely on the immediate satisfaction of cleaning rather than long-term progression systems that can create addictive patterns.</p>
            <p>The game is also completely unblocked, meaning it works on school networks, office wifi, and other restricted internet connections that typically block gaming sites. This has made Cash Cleaner Online particularly popular among students looking for quick study breaks and office workers seeking momentary stress relief during busy workdays.</p>
        </section>

        <div id="adBottom">
            <script>
              atOptions = {
                'key' : 'ec8c5f314722aa8c54e18afcf25d60c7',
                'format' : 'iframe',
                'height' : 90,
                'width' : 728,
                'params' : {}
              };
            </script>
            <script src="https://offeringmakeup.com/ec8c5f314722aa8c54e18afcf25d60c7/invoke.js"></script>
        </div>

        <footer>
            <a href="/privacy.html">Privacy Policy</a> |
            <a href="/terms.html">Terms of Service</a> |
            <a href="/about.html">About Us</a> |
            <a href="/contact.html">Contact</a>
        </footer>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';

        // ===== Global State =====
        let scene, camera, renderer, controls;
        let bills = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        // Camera control state
        let isDragging = false;

        // Cleaning system state
        let isCleaning = false;
        let currentBill = null;
        let brushSize = 25;
        let brushIntensity = 1.0;
        let isFineBrush = false;
        const maskResolution = 256;
        let totalCleanProgress = 0;
        let needsTextureUpdate = false;
        let cleanedCount = 0;

        // Audio system
        let audioContext;
        let cleaningSound;
        let cleaningSoundGain;
        let isAudioInitialized = false;

        // Scene dimensions (computed from geometry)
        const roomDimensions = { width: 12, height: 6, depth: 12 };
        const tableDimensions = { width: 3, height: 0.1, depth: 2, posY: 1 };
        const floorY = 0;
        const collisionMargin = 0.3;

        // ===== Init =====
        function init() {
            createScene();
            createLights();
            createRoom();
            createTable();
            createProps();
            createMoney();
            bindInput();
            initAudio();
            animate();
        }

        // ===== Audio System =====
        function initAudio() {
            // Lazy init on first user interaction
            document.addEventListener('click', () => {
                if (!isAudioInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    cleaningSoundGain = audioContext.createGain();
                    cleaningSoundGain.gain.value = 0;
                    cleaningSoundGain.connect(audioContext.destination);
                    isAudioInitialized = true;
                    console.log('Audio initialized');
                }
            }, { once: true });
        }

        function startCleaningSound() {
            if (!isAudioInitialized) return;
            
            // Create white noise for scrubbing sound
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.1;
            }
            
            cleaningSound = audioContext.createBufferSource();
            cleaningSound.buffer = buffer;
            cleaningSound.loop = true;
            
            // Filter for more natural sound
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 3000;
            
            cleaningSound.connect(filter);
            filter.connect(cleaningSoundGain);
            cleaningSound.start();
            
            // Fade in
            cleaningSoundGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.1);
        }

        function stopCleaningSound() {
            if (!cleaningSoundGain) return;
            
            // Fade out
            cleaningSoundGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
            
            if (cleaningSound) {
                setTimeout(() => {
                    try { cleaningSound.stop(); } catch(e) {}
                    cleaningSound = null;
                }, 250);
            }
        }

        function playCompleteSound() {
            if (!isAudioInitialized) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.frequency.value = 800;
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // ===== Scene Setup =====
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 8, 20);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 4, 5);
            camera.lookAt(0, 1.1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.physicallyCorrectLights = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.enablePan = false;
            controls.rotateSpeed = 0.9;
            controls.zoomSpeed = 0.9;
            controls.minDistance = 2.6;
            controls.maxDistance = 7.0;
            controls.minPolarAngle = Math.PI * 0.18;
            controls.maxPolarAngle = Math.PI * 0.48;
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        // ===== Lights =====
        function createLights() {
            // Ambient light - cool tone, weak
            const ambientLight = new THREE.AmbientLight(0x6688bb, 0.3);
            scene.add(ambientLight);

            // Hemisphere light - cool top, warm ground
            const hemiLight = new THREE.HemisphereLight(0x5577cc, 0x664422, 0.5);
            scene.add(hemiLight);

            // Main spotlight from ceiling
            const spotLight = new THREE.SpotLight(0xfffff0, 120);
            spotLight.position.set(0, 5.5, 0.5);
            spotLight.target.position.set(0, 1, 0);
            spotLight.angle = Math.PI / 4.5;
            spotLight.penumbra = 0.4;
            spotLight.decay = 2;
            spotLight.distance = 10;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 10;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);
            scene.add(spotLight.target);

            // RectAreaLight - key fill light from side-front
            const rectLight = new THREE.RectAreaLight(0xffffff, 4, 3, 2);
            rectLight.position.set(2, 2, 3);
            rectLight.lookAt(0, 1, 0);
            scene.add(rectLight);

            // Additional soft fill from opposite side
            const fillLight = new THREE.PointLight(0xaabbcc, 0.8, 8);
            fillLight.position.set(-2, 2.5, 2);
            scene.add(fillLight);
        }

        // ===== Room =====
        function createRoom() {
            // Inverted box for basement room - backside normals
            const roomGeo = new THREE.BoxGeometry(12, 6, 12);
            const roomMat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                side: THREE.BackSide,
                roughness: 0.9,
                metalness: 0.05
            });
            const room = new THREE.Mesh(roomGeo, roomMat);
            room.position.y = 3;
            room.receiveShadow = true;
            scene.add(room);

            // Floor with slight reflectivity
            const floorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x424242,
                roughness: 0.7,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        // ===== Table =====
        function createTable() {
            // Wood material with procedural variation
            const tableMat = new THREE.MeshStandardMaterial({
                color: 0x5a3825,
                roughness: 0.7,
                metalness: 0.05,
                roughnessMap: createWoodRoughnessMap()
            });

            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 2),
                tableMat
            );
            tableTop.position.set(0, 1, 0);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            scene.add(tableTop);

            const legGeo = new THREE.BoxGeometry(0.1, 0.9, 0.1);
            const positions = [
                [-1.3, 0.45, -0.85],
                [1.3, 0.45, -0.85],
                [-1.3, 0.45, 0.85],
                [1.3, 0.45, 0.85]
            ];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });
        }

        function createWoodRoughnessMap() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base wood color with grain
            for (let y = 0; y < size; y++) {
                const grainIntensity = Math.sin(y * 0.1) * 20 + 128;
                ctx.fillStyle = `rgb(${grainIntensity},${grainIntensity},${grainIntensity})`;
                ctx.fillRect(0, y, size, 1);
            }
            
            // Add noise variation
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = data[i];
                data[i+2] = data[i];
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            return texture;
        }

        // ===== Room Props =====
        function createProps() {
            // Crate in corner
            const crateMat = new THREE.MeshStandardMaterial({
                color: 0x5a4a3a,
                roughness: 0.9,
                metalness: 0.0
            });
            const crate = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), crateMat);
            crate.position.set(-4, 0.4, -4);
            crate.rotation.y = 0.3;
            crate.castShadow = true;
            crate.receiveShadow = true;
            scene.add(crate);

            // Pipes along wall
            const pipeMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.4,
                metalness: 0.6
            });
            const pipe1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4, 8), pipeMat);
            pipe1.position.set(-5.9, 1.5, 0);
            pipe1.rotation.z = Math.PI / 2;
            pipe1.castShadow = true;
            scene.add(pipe1);

            // Neon strip light
            const neonGeo = new THREE.BoxGeometry(2, 0.05, 0.05);
            const neonMat = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 2,
                roughness: 0.2,
                metalness: 0.8
            });
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.position.set(3, 2.5, -5.9);
            scene.add(neon);

            // Add small point light for neon
            const neonLight = new THREE.PointLight(0x00ff88, 0.5, 3);
            neonLight.position.copy(neon.position);
            scene.add(neonLight);
        }

        // ===== Mask Canvas System =====
        function createMaskCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = maskResolution;
            canvas.height = maskResolution;
            const ctx = canvas.getContext('2d');
            // Start fully dirty (black = dirty)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, maskResolution, maskResolution);
            return { canvas, ctx };
        }

        function drawCleanBrush(ctx, x, y, size, intensity) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity})`);
            gradient.addColorStop(0.7, `rgba(255, 255, 255, ${intensity * 0.5})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }

        function calculateCleanProgress(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let whitePixels = 0;
            let totalPixels = canvas.width * canvas.height;
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] > 128) whitePixels++; // White threshold
            }
            
            return whitePixels / totalPixels;
        }

        // ===== Money =====
        function createMoney() {
            const billGeo = new THREE.PlaneGeometry(0.15, 0.065);
            const billColors = [0x85c97f, 0x7abf73, 0x9acd92];

            for (let i = 0; i < 80; i++) {
                const baseColor = billColors[Math.floor(Math.random() * billColors.length)];
                
                // Create mask canvas
                const maskData = createMaskCanvas();
                const maskTexture = new THREE.CanvasTexture(maskData.canvas);
                maskTexture.needsUpdate = true;

                // Create material with custom shader
                const billMat = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    roughness: 0.5,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });

                // Custom onBeforeCompile for dirt masking
                billMat.onBeforeCompile = (shader) => {
                    shader.uniforms.maskTexture = { value: maskTexture };
                    shader.uniforms.dirtColor = { value: new THREE.Color(0x3a2a1a) };
                    
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <color_fragment>',
                        `
                        #include <color_fragment>
                        uniform sampler2D maskTexture;
                        uniform vec3 dirtColor;
                        vec4 maskSample = texture2D(maskTexture, vUv);
                        float cleanAmount = maskSample.r;
                        diffuseColor.rgb = mix(dirtColor, diffuseColor.rgb, cleanAmount);
                        `
                    );
                };

                const bill = new THREE.Mesh(billGeo, billMat);
                bill.position.set(
                    (Math.random() - 0.5) * 2.4,
                    1.05 + Math.random() * 0.15,
                    (Math.random() - 0.5) * 1.6
                );
                bill.rotation.set(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.3
                );
                bill.castShadow = true;
                bill.receiveShadow = true;
                bill.userData = {
                    id: i,
                    cleanProgress: 0,
                    isDirty: true,
                    maskData: maskData,
                    maskTexture: maskTexture
                };
                bills.push(bill);
                scene.add(bill);
            }
        }

        // ===== Input =====
        function bindInput() {
            window.addEventListener('resize', onResize);
            window.addEventListener('click', onClick);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mousemove', onMouseMove);
        }

        function updateCleaningUI(progress) {
            const percent = Math.floor(progress * 100);
            document.getElementById('progressText').textContent = percent + '%';
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function showCleanedNotice() {
            const notice = document.getElementById('cleanedNotice');
            notice.classList.add('show');
            playCompleteSound();
            cleanedCount++;
            
            setTimeout(() => {
                notice.classList.remove('show');
                generateNextBill();
            }, 2000);
            
            console.log(`Bill cleaned! Total: ${cleanedCount}`);
        }

        function generateNextBill() {
            if (!currentBill) return;
            
            // Dispose old bill
            disposeBill(currentBill);
            bills = bills.filter(b => b !== currentBill);
            scene.remove(currentBill);
            currentBill = null;
            
            // Create new bill
            const billGeo = new THREE.PlaneGeometry(0.15, 0.065);
            const baseColor = [0x85c97f, 0x7abf73, 0x9acd92][Math.floor(Math.random() * 3)];
            
            const maskData = createMaskCanvas();
            const maskTexture = new THREE.CanvasTexture(maskData.canvas);
            maskTexture.needsUpdate = true;

            const billMat = new THREE.MeshStandardMaterial({
                color: baseColor,
                roughness: 0.5,
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            billMat.onBeforeCompile = (shader) => {
                shader.uniforms.maskTexture = { value: maskTexture };
                shader.uniforms.dirtColor = { value: new THREE.Color(0x3a2a1a) };
                
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <color_fragment>',
                    `
                    #include <color_fragment>
                    uniform sampler2D maskTexture;
                    uniform vec3 dirtColor;
                    vec4 maskSample = texture2D(maskTexture, vUv);
                    float cleanAmount = maskSample.r;
                    diffuseColor.rgb = mix(dirtColor, diffuseColor.rgb, cleanAmount);
                    `
                );
            };

            const bill = new THREE.Mesh(billGeo, billMat);
            bill.position.set(
                (Math.random() - 0.5) * 2.4,
                1.05 + Math.random() * 0.1,
                (Math.random() - 0.5) * 1.6
            );
            bill.rotation.set(
                (Math.random() - 0.5) * 0.2,
                Math.random() * Math.PI * 2,
                (Math.random() - 0.5) * 0.3
            );
            bill.castShadow = true;
            bill.receiveShadow = true;
            bill.userData = {
                id: Date.now(),
                cleanProgress: 0,
                isDirty: true,
                maskData: maskData,
                maskTexture: maskTexture
            };
            
            bills.push(bill);
            scene.add(bill);
            
            // Reset progress UI
            updateCleaningUI(0);
        }

        function disposeBill(bill) {
            if (!bill) return;
            
            // Dispose geometry
            if (bill.geometry) {
                bill.geometry.dispose();
            }
            
            // Dispose material and textures
            if (bill.material) {
                if (bill.material.map) bill.material.map.dispose();
                bill.material.dispose();
            }
            
            // Dispose mask texture
            if (bill.userData.maskTexture) {
                bill.userData.maskTexture.dispose();
            }
            
            // Clear canvas context
            if (bill.userData.maskData && bill.userData.maskData.canvas) {
                bill.userData.maskData.canvas.width = 1;
                bill.userData.maskData.canvas.height = 1;
            }
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(bills);
                
                if (intersects.length > 0) {
                    isCleaning = true;
                    currentBill = intersects[0].object;
                    cleanAtPoint(intersects[0]);
                    startCleaningSound();
                    // Disable orbit while cleaning
                    controls.enabled = false;
                } else {
                    isDragging = true;
                }
            }
        }

        function onMouseUp() {
            if (isCleaning) {
                stopCleaningSound();
                controls.enabled = true; // Re-enable orbit after cleaning
            }
            isCleaning = false;
            currentBill = null;
            isDragging = false;
        }

        function onMouseMove(event) {
            // Continue cleaning if mouse is down
            if (isCleaning && currentBill) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([currentBill]);
                if (intersects.length > 0) {
                    cleanAtPoint(intersects[0]);
                }
            }
        }

        // ===== Camera Clamping =====
        function clampCamera() {
            const pos = camera.position;
            
            // 1. Floor constraint
            if (pos.y < floorY + collisionMargin) {
                pos.y = floorY + collisionMargin;
            }
            
            // 2. Room boundary constraints
            const roomHalfX = roomDimensions.width / 2 - collisionMargin;
            const roomHalfZ = roomDimensions.depth / 2 - collisionMargin;
            
            pos.x = THREE.MathUtils.clamp(pos.x, -roomHalfX, roomHalfX);
            pos.z = THREE.MathUtils.clamp(pos.z, -roomHalfZ, roomHalfZ);
            
            // 3. Table collision (Box3 check)
            const tableBox = new THREE.Box3(
                new THREE.Vector3(
                    -tableDimensions.width / 2 - collisionMargin,
                    tableDimensions.posY - tableDimensions.height / 2 - collisionMargin,
                    -tableDimensions.depth / 2 - collisionMargin
                ),
                new THREE.Vector3(
                    tableDimensions.width / 2 + collisionMargin,
                    tableDimensions.posY + tableDimensions.height / 2 + collisionMargin,
                    tableDimensions.depth / 2 + collisionMargin
                )
            );
            
            if (tableBox.containsPoint(pos)) {
                // Push camera out from table center
                const tableCenter = new THREE.Vector3(0, tableDimensions.posY, 0);
                const pushDir = pos.clone().sub(tableCenter).normalize();
                
                // Find closest point on box boundary
                const closestPoint = tableBox.clampPoint(pos, new THREE.Vector3());
                const pushDistance = collisionMargin * 1.5;
                
                pos.copy(closestPoint).add(pushDir.multiplyScalar(pushDistance));
                
                // Update controls distance if needed
                const distToTarget = pos.distanceTo(controls.target);
                if (distToTarget < controls.minDistance) {
                    controls.minDistance = distToTarget + 0.1;
                }
            }
        }

        function cleanAtPoint(intersection) {
            const bill = intersection.object;
            const uv = intersection.uv;
            const userData = bill.userData;
            
            if (!uv || !userData.maskData) return;

            const x = Math.floor(uv.x * maskResolution);
            const y = Math.floor((1 - uv.y) * maskResolution);
            
            const effectiveBrushSize = isFineBrush ? brushSize * 0.5 : brushSize;
            const effectiveIntensity = isFineBrush ? brushIntensity * 0.6 : brushIntensity;
            
            drawCleanBrush(userData.maskData.ctx, x, y, effectiveBrushSize, effectiveIntensity);
            needsTextureUpdate = true;
            
            // Update progress
            userData.cleanProgress = calculateCleanProgress(userData.maskData.canvas);
            updateCleaningUI(userData.cleanProgress);
            
            if (userData.cleanProgress >= 0.85 && userData.isDirty) {
                userData.isDirty = false;
                showCleanedNotice();
            }
        }

        function onClick(event) {
            // Keep for compatibility
        }

        function onKeyDown(event) {
            if (event.key === 'Shift') {
                isFineBrush = true;
            }
            
            switch(event.key.toLowerCase()) {
                case 'h':
                    toggleSEO();
                    break;
                case 'l':
                    renderer.toneMappingExposure = Math.min(3, renderer.toneMappingExposure + 0.1);
                    updateHUD();
                    break;
                case 'k':
                    renderer.toneMappingExposure = Math.max(0.5, renderer.toneMappingExposure - 0.1);
                    updateHUD();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case '[':
                    brushSize = Math.max(10, brushSize - 5);
                    updateHUD();
                    break;
                case ']':
                    brushSize = Math.min(50, brushSize + 5);
                    updateHUD();
                    break;
            }
        }

        function onKeyUp(event) {
            if (event.key === 'Shift') {
                isFineBrush = false;
            }
        }

        function resetCamera() {
            camera.position.set(0, 4, 5);
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== Animation Loop =====
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = now - lastTime;
            lastTime = now;

            frameCount++;
            fpsTime += delta;
            if (fpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // Update mask textures (throttled)
            if (needsTextureUpdate && currentBill) {
                currentBill.userData.maskTexture.needsUpdate = true;
                needsTextureUpdate = false;
            }

            controls.update();
            clampCamera(); // Prevent camera clipping through objects
            updateHUD();
            renderer.render(scene, camera);
        }

        // ===== HUD =====
        function updateHUD() {
            const pos = camera.position;
            document.getElementById('camPos').textContent = 
                `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;
            document.getElementById('exposure').textContent = 
                renderer.toneMappingExposure.toFixed(1);
            document.getElementById('brushSize').textContent = 
                isFineBrush ? Math.floor(brushSize * 0.5) : brushSize;
            document.getElementById('cleanedCount').textContent = cleanedCount;
        }

        // ===== SEO Toggle =====
        window.toggleSEO = function() {
            document.getElementById('seoOverlay').classList.toggle('hidden');
        }

        // Start
        init();
    </script>

    <script src="https://offeringmakeup.com/a0/2d/50/a02d50405ef0bdf0d4243259c7266ce6.js"></script>
</body>
</html>
