<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Cash Cleaner Online - Realistic 3D Money Washing Simulator</title>
    <meta name="description" content="Experience the ultimate ASMR money washing simulator. Clean dirty bills in a realistic 3D basement environment. Play Cash Cleaner Online for free now!">
    <meta name="keywords" content="cash cleaner, money washing game, asmr simulator, unblocked games, cash cleaner online, money cleaner, satisfying game, asmr game, 3d cleaning simulator">
    <meta name="author" content="Cash Cleaner Online">
    <link rel="canonical" href="https://cashcleaner.online/">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
    <meta property="og:title" content="Cash Cleaner Online - Realistic 3D Money Washing Simulator">
    <meta property="og:description" content="Experience the ultimate ASMR money washing simulator. Clean dirty bills in a realistic 3D basement environment. Play for free now!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cashcleaner.online/">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Fullscreen Canvas */
        canvas {
            position: fixed;
            inset: 0;
            display: block;
        }

        /* Score Board HUD */
        #score-board {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 15px 25px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            line-height: 1.4;
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            z-index: 1000;
            user-select: none;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #score-board .label {
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            margin-bottom: 5px;
        }

        /* Mode & Tool UI */
        #mode-tool-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

        #mode-tool-ui .section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        #mode-tool-ui .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        #mode-tool-ui .label {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.6);
            margin-bottom: 5px;
        }

        #mode-tool-ui .value {
            font-size: 16px;
            font-weight: bold;
        }

        #mode-tool-ui .btn {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: all 0.2s;
        }

        #mode-tool-ui .btn:hover:not(.disabled) {
            background: rgba(0, 255, 136, 0.4);
        }

        #mode-tool-ui .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: #666;
            border-color: #666;
        }

        /* Debug HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            z-index: 1000;
            user-select: none;
        }

        #hud div {
            margin: 2px 0;
        }

        /* SEO Overlay */
        #seoOverlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            max-height: 50vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: #ffffff;
            z-index: 900;
            transition: transform 0.3s ease;
        }

        #seoOverlay.hidden {
            transform: translateY(100%);
        }

        #seoToggle {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            z-index: 901;
            user-select: none;
        }

        #seoToggle:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        #content {
            width: 100%;
            max-width: 900px;
            padding: 40px 20px;
            margin: 0 auto;
            line-height: 1.8;
            user-select: text;
        }

        #content h2 {
            color: #00ff88;
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #content h2:first-child {
            margin-top: 0;
        }

        #content p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 15px;
            margin-bottom: 15px;
            text-align: justify;
        }

        #adBottom {
            text-align: center;
            padding: 30px 0;
            background: rgba(0, 0, 0, 0.8);
        }

        footer {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        footer a {
            color: #00ff88;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Collect Feedback */
        #collectFeedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #00ff88, #00cc66);
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #111;
            z-index: 2000;
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        #collectFeedback.show {
            transform: translate(-50%, -50%) scale(1);
        }

        /* Back Button (Focus View) */
        #backButton {
            position: fixed;
            top: 20px;
            left: 50%; /* Center horizontally */
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            z-index: 2000;
            transition: all 0.3s;
            display: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        #backButton:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
        }

        #backButton.show {
            display: block;
        }

        /* SEO H1 - Visually hidden but accessible */
        #seo-h1 {
            position: absolute;
            left: -10000px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            #content {
                padding: 30px 15px;
            }
            #content h2 {
                font-size: 20px;
            }
            #content p {
                font-size: 14px;
            }
            #hud {
                font-size: 10px;
                padding: 8px;
            }
            #score-board {
                font-size: 18px;
                padding: 12px 20px;
            }
            #score-board .label {
                font-size: 12px;
            }
            #mode-tool-ui {
                font-size: 12px;
                padding: 10px;
            }
            #mode-tool-ui .value {
                font-size: 14px;
            }
            #mode-tool-ui .btn {
                font-size: 11px;
                padding: 5px 10px;
            }
        }
    </style>
</head>
<body>
    <h1 id="seo-h1">Cash Cleaner Online - The Best 3D Cleaning Simulator</h1>

    <div id="score-board">
        <div class="label">CLEANED</div>
        <div id="scoreAmount">$0</div>
    </div>

    <div id="mode-tool-ui">
        <div class="section">
            <div class="label">MODE (SPACE)</div>
            <div class="value" id="currentMode">HAND</div>
        </div>
        <div class="section">
            <div class="label">CURRENT TOOL</div>
            <div class="value" id="currentTool">Eraser</div>
        </div>
        <div class="section">
            <div class="label">SHOP</div>
            <button class="btn" id="buyBrushBtn" onclick="buyBrush()">Buy Brush $500</button>
        </div>
        <div class="section">
            <div class="label">BOX MONEY</div>
            <div class="value" id="boxMoneyCount">30</div>
        </div>
    </div>

    <div id="hud" style="display:none;">
        <div>FPS: <span id="fps">0</span></div>
        <div>Cleaned: <span id="cleanedCount">0</span></div>
        <div>Camera: <span id="camPos">0,0,0</span></div>
        <div>Exposure: <span id="exposure">1.25</span></div>
        <div style="margin-top:8px;color:#888">H: Info | L/K: Exposure</div>
    </div>

    <div id="collectFeedback">+$100</div>

    <button id="backButton" onclick="returnToGlobalView()">‚Üê BACK TO OVERVIEW</button>

    <div id="seoToggle" onclick="toggleSEO()">Press H for Info</div>

    <div id="seoOverlay" class="hidden">
        <section id="content">
            <h2>What is Cash Cleaner Online?</h2>
            <p>Cash Cleaner Online is a free-to-play browser-based cleaning simulator...</p>
            </section>

        <div id="adBottom">
            <script>
              atOptions = {
                'key' : 'ec8c5f314722aa8c54e18afcf25d60c7',
                'format' : 'iframe',
                'height' : 90,
                'width' : 728,
                'params' : {}
              };
            </script>
            <script src="https://offeringmakeup.com/ec8c5f314722aa8c54e18afcf25d60c7/invoke.js"></script>
        </div>

        <footer>
            <a href="/privacy.html">Privacy Policy</a> |
            <a href="/terms.html">Terms of Service</a> |
            <a href="/about.html">About Us</a> |
            <a href="/contact.html">Contact</a>
        </footer>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ===== Global State =====
        let scene, camera, renderer;
        let bills = [];
        let cashBoxOnTable = null;
        let cashBoxOnFloor = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-999, -999);
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        // Interaction state
        let hoveredBill = null;
        let selectedBill = null;
        let totalScore = 0;
        let cleanedCount = 0;
        let boxMoneyCount = 30;

        // Mode & Tool system
        let currentMode = 'HAND'; // 'HAND' or 'TOOL'
        let currentTool = 'Eraser'; // 'Eraser' or 'Brush'
        let toolRadius = { Eraser: 30, Brush: 60 }; // Increased Eraser size slightly
        let ownedTools = ['Eraser'];
        const toolPrices = { Brush: 500 };

        // View State Machine
        let viewState = 'OVERVIEW'; // 'OVERVIEW' | 'FOCUS'
        const CAMERA_STATES = {
            OVERVIEW: {
                position: { x: 0, y: 2.0, z: 4.0 },
                target: { x: 0, y: 1.2, z: 0 }
            },
            FOCUS: {
                position: { x: 0, y: 2.2, z: 1.8 },
                target: { x: 0, y: 1.0, z: 0 }
            }
        };
        let workTableLight = null;
        let tableTop = null;

        // Cleaning state
        let isCleaning = false;
        let lastCleanCheck = 0;
        const CLEAN_CHECK_INTERVAL = 500;

        // Audio system
        let audioContext;
        let isAudioInitialized = false;

        // ===== Init =====
        function init() {
            createScene();
            createLights();
            createRoom();
            createTable();
            createCashBoxes();
            createProps();
            bindInput();
            initAudio();
            updateUI();
            // animate() will be called at script end
        }

        // ===== Audio System =====
        function initAudio() {
            document.addEventListener('click', () => {
                if (!isAudioInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    isAudioInitialized = true;
                }
            }, { once: true });
        }

        function playCollectSound() {
            if (!isAudioInitialized) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // ===== Scene Setup =====
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 8, 20);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 4); // OVERVIEW mode position
            camera.lookAt(0, 1.2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x050505, 1); // Deep gray background
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
        }

        // ===== Lights =====
        function createLights() {
            // Base ambient light (fallback to prevent black screen)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // Additional colored ambient light
            const coloredAmbient = new THREE.AmbientLight(0x6688bb, 0.3);
            scene.add(coloredAmbient);
            
            const hemiLight = new THREE.HemisphereLight(0x5577cc, 0x664422, 0.5);
            scene.add(hemiLight);

            const spotLight = new THREE.SpotLight(0xfffff0, 120);
            spotLight.position.set(0, 5.5, 0.5);
            spotLight.target.position.set(0, 1, 0);
            spotLight.castShadow = true;
            scene.add(spotLight);
            scene.add(spotLight.target);

            workTableLight = new THREE.PointLight(0xffffff, 0, 5);
            workTableLight.position.set(0, 2, 0);
            scene.add(workTableLight);
        }

        // ===== Room & Props =====
        function createRoom() {
            const roomGeo = new THREE.BoxGeometry(12, 6, 12);
            const roomMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, side: THREE.BackSide });
            const room = new THREE.Mesh(roomGeo, roomMat);
            room.position.y = 3;
            room.receiveShadow = true;
            scene.add(room);

            const floorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x424242 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createTable() {
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            tableTop = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 2), tableMat);
            tableTop.position.set(0, 1, 0);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            tableTop.userData.type = 'table';
            scene.add(tableTop);

            const legGeo = new THREE.BoxGeometry(0.1, 0.9, 0.1);
            [[-1.3,0.45,-0.85], [1.3,0.45,-0.85], [-1.3,0.45,0.85], [1.3,0.45,0.85]].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });
        }

        function createCashBoxes() {
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x8b6f47 });
            cashBoxOnTable = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.3), boxMat);
            cashBoxOnTable.position.set(0.9, 1.125, 0);
            cashBoxOnTable.castShadow = true;
            cashBoxOnTable.receiveShadow = true;
            scene.add(cashBoxOnTable);
        }

        function createProps() {
            // Neon Light
            const neonGeo = new THREE.BoxGeometry(2, 0.05, 0.05);
            const neonMat = new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 2 });
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.position.set(0, 2.5, -3); // Moved closer to be visible
            scene.add(neon);
        }

        // ===== Bill Class (The Sandwich Method) =====
        function createBillTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256; // 2:1 Ratio
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a5a3b';
            ctx.fillRect(0, 0, 512, 256);
            ctx.strokeStyle = '#1a3a2b';
            ctx.lineWidth = 20;
            ctx.strokeRect(10, 10, 492, 236);
            ctx.fillStyle = '#b8e0c3';
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$100', 256, 128);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; // Pure black dirt
            ctx.fillRect(0, 0, 512, 256);
            // Noise
            for(let i=0; i<300; i++) {
                ctx.clearRect(Math.random()*512, Math.random()*256, 5, 5);
            }
            const texture = new THREE.CanvasTexture(canvas);
            return { texture, canvas, ctx };
        }

        class Bill {
            constructor(x, y, z) {
                this.isDirty = true;
                this.value = 100;
                this.baseY = y;
                
                this.billTexture = createBillTexture();
                const dirtData = createDirtTexture();
                this.dirtTexture = dirtData.texture;
                this.dirtCanvas = dirtData.canvas;
                this.dirtCtx = dirtData.ctx;
                
                const geometry = new THREE.PlaneGeometry(0.6, 0.3);
                
                this.group = new THREE.Group();
                this.group.position.set(x, y, z);
                this.group.rotation.set(-Math.PI / 2, Math.random() * Math.PI * 2, 0);
                
                // Bottom: Green Bill
                const billMat = new THREE.MeshStandardMaterial({ map: this.billTexture });
                this.billMesh = new THREE.Mesh(geometry, billMat);
                this.group.add(this.billMesh);
                
                // Top: Dirt Layer
                const dirtMat = new THREE.MeshBasicMaterial({ 
                    map: this.dirtTexture, 
                    transparent: true, 
                    opacity: 1.0 
                });
                this.dirtMesh = new THREE.Mesh(geometry, dirtMat);
                this.dirtMesh.position.z = 0.005; // Slightly above (relative to plane Z)
                this.group.add(this.dirtMesh);
                
                // Link for raycasting
                this.group.userData.billInstance = this;
                this.dirtMesh.userData.billInstance = this;
                this.billMesh.userData.billInstance = this;
                
                // Crucial for raycaster to find children
                this.mesh = this.group;
            }
            
            erase(uv, brushSize) {
                const ctx = this.dirtCtx;
                const x = uv.x * this.dirtCanvas.width;
                const y = (1 - uv.y) * this.dirtCanvas.height; // UV Y is inverted
                
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, Math.PI * 2);
                ctx.fill();
                
                this.dirtTexture.needsUpdate = true;
            }
            
            isClean() {
                // Check every 50th pixel to save performance
                const w = this.dirtCanvas.width;
                const h = this.dirtCanvas.height;
                const imgData = this.dirtCtx.getImageData(0, 0, w, h);
                let opaque = 0;
                let totalChecked = 0;
                
                for (let i = 3; i < imgData.data.length; i += 4 * 50) {
                    totalChecked++;
                    if (imgData.data[i] > 20) opaque++;
                }
                return (opaque / totalChecked) < 0.05; // 95% clean
            }
            
            dispose() {
                this.billTexture.dispose();
                this.dirtTexture.dispose();
                this.billMesh.geometry.dispose();
                this.billMesh.material.dispose();
                this.dirtMesh.geometry.dispose();
                this.dirtMesh.material.dispose();
            }
        }

        // ===== Spawning =====
        function spawnBillFromBox() {
            if (boxMoneyCount <= 0) return;
            const randomX = (Math.random() - 0.5) * 1.5;
            const randomZ = (Math.random() - 0.5) * 1.0;
            const randomY = 1.055 + Math.random() * 0.01;
            
            const bill = new Bill(randomX, randomY, randomZ);
            bills.push(bill);
            scene.add(bill.mesh);
            
            boxMoneyCount--;
            updateUI();
        }

        // ===== Interaction Logic (FIXED) =====
        function updateInteraction() {
            raycaster.setFromCamera(mouse, camera);
            
            if (viewState === 'OVERVIEW') {
                // Only hover table
                const intersects = raycaster.intersectObjects([tableTop], false);
                if (intersects.length > 0) {
                    tableTop.material.emissive.setHex(0x00ff00);
                    tableTop.material.emissiveIntensity = 0.3;
                    document.body.style.cursor = 'pointer';
                } else {
                    tableTop.material.emissive.setHex(0x000000);
                    tableTop.material.emissiveIntensity = 0;
                    document.body.style.cursor = 'default';
                }
            }
        }

        function cleanAtPoint(intersection) {
            const billInstance = intersection.object.userData.billInstance;
            if (!billInstance) return;
            
            // Map UV to scratch
            const brushSize = toolRadius[currentTool];
            billInstance.erase(intersection.uv, brushSize);
            
            if (billInstance.isDirty && billInstance.isClean()) {
                billInstance.isDirty = false;
                completeBillCleaning(billInstance);
            }
        }

        function checkCleanStatus() {
            bills.forEach(bill => {
                if (bill.isDirty && bill.isClean()) {
                    bill.isDirty = false;
                    completeBillCleaning(bill);
                }
            });
        }

        function completeBillCleaning(bill) {
            const startY = bill.group.position.y;
            
            // Fly animation
            new TWEEN.Tween(bill.group.position)
                .to({ y: startY + 1.5 }, 800)
                .start();
                
            new TWEEN.Tween(bill.group.scale)
                .to({ x: 0, y: 0, z: 0 }, 800)
                .onComplete(() => {
                    scene.remove(bill.group);
                    bills = bills.filter(b => b !== bill);
                    bill.dispose();
                })
                .start();

            totalScore += 100;
            cleanedCount++;
            updateUI();
            showCollectFeedback(100);
            playCollectSound();
        }

        function updateUI() {
            document.getElementById('scoreAmount').textContent = '$' + totalScore;
            document.getElementById('cleanedCount').textContent = cleanedCount;
            document.getElementById('currentMode').textContent = currentMode;
            document.getElementById('currentTool').textContent = currentTool;
            document.getElementById('boxMoneyCount').textContent = boxMoneyCount;
            
            const buyBtn = document.getElementById('buyBrushBtn');
            if (ownedTools.includes('Brush')) {
                buyBtn.textContent = 'Brush Owned';
                buyBtn.classList.add('disabled');
            } else if (totalScore >= toolPrices.Brush) {
                buyBtn.classList.remove('disabled');
            }
        }

        function tweenToFocus() {
            if (viewState === 'FOCUS') return;
            viewState = 'FOCUS';
            
            // Remove highlight
            tableTop.material.emissive.setHex(0x000000);
            document.body.style.cursor = 'default';

            new TWEEN.Tween(camera.position).to(CAMERA_STATES.FOCUS.position, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
            
            // Tween LookAt (simplified for stability)
            const currentLook = new THREE.Vector3();
            camera.getWorldDirection(currentLook);
            const targetLook = new THREE.Vector3(0, 1, 0); // Looking at table center
            
            // We just move camera position mostly, and set lookAt in update
            new TWEEN.Tween(workTableLight).to({ intensity: 3 }, 500).start();
            
            document.getElementById('backButton').classList.add('show');
            document.getElementById('mode-tool-ui').style.display = 'none';
            currentMode = 'TOOL';
            updateUI();
        }

        function returnToOverview() {
            if (viewState === 'OVERVIEW') return;
            viewState = 'OVERVIEW';
            
            new TWEEN.Tween(camera.position).to(CAMERA_STATES.OVERVIEW.position, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
            new TWEEN.Tween(workTableLight).to({ intensity: 0 }, 500).start();
            
            document.getElementById('backButton').classList.remove('show');
            document.getElementById('mode-tool-ui').style.display = 'block';
            currentMode = 'HAND';
            updateUI();
        }
        window.returnToGlobalView = returnToOverview;

        function showCollectFeedback(value) {
            const feedback = document.getElementById('collectFeedback');
            feedback.textContent = '+$' + value;
            feedback.classList.add('show');
            setTimeout(() => feedback.classList.remove('show'), 500);
        }
        
        window.buyBrush = function() {
            if (ownedTools.includes('Brush')) return;
            if (totalScore >= toolPrices.Brush) {
                totalScore -= toolPrices.Brush;
                ownedTools.push('Brush');
                currentTool = 'Brush';
                updateUI();
                playCollectSound();
            }
        }

        // ===== Inputs =====
        function bindInput() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            window.addEventListener('mousedown', (e) => {
                if(e.button !== 0) return;
                raycaster.setFromCamera(mouse, camera);
                
                if (viewState === 'OVERVIEW') {
                    const hits = raycaster.intersectObjects([tableTop], false);
                    if (hits.length > 0) tweenToFocus();
                } 
                else if (viewState === 'FOCUS') {
                    // Check Box
                    const boxHits = raycaster.intersectObjects([cashBoxOnTable], false);
                    if (boxHits.length > 0) {
                        spawnBillFromBox();
                        return;
                    }
                    
                    // Check Bills (CRITICAL: Recursive = true)
                    const billMeshes = bills.map(b => b.group);
                    const billHits = raycaster.intersectObjects(billMeshes, true);
                    
                    if (billHits.length > 0) {
                        isCleaning = true;
                        selectedBill = billHits[0].object.userData.billInstance;
                        cleanAtPoint(billHits[0]);
                    }
                }
            });
            
            window.addEventListener('mouseup', () => { isCleaning = false; selectedBill = null; });
            
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                if (viewState === 'FOCUS' && isCleaning && selectedBill) {
                    raycaster.setFromCamera(mouse, camera);
                    // CRITICAL: Recursive = true
                    const hits = raycaster.intersectObjects(bills.map(b => b.group), true);
                    if (hits.length > 0) cleanAtPoint(hits[0]);
                }
            });
            
            window.addEventListener('keydown', (e) => {
                if(e.key === ' ') { 
                    currentMode = currentMode === 'HAND' ? 'TOOL' : 'HAND'; 
                    updateUI(); 
                }
                if(e.key.toLowerCase() === 'h') toggleSEO();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            TWEEN.update();
            updateInteraction();
            if (now - lastCleanCheck >= CLEAN_CHECK_INTERVAL) {
                checkCleanStatus();
                lastCleanCheck = now;
            }
            renderer.render(scene, camera);
        }
        
        // Start the application
        init();
        animate(); // Start the render loop
    </script>

    <script src="https://offeringmakeup.com/a0/2d/50/a02d50405ef0bdf0d4243259c7266ce6.js"></script>
</body>
</html>