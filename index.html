<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Cash Cleaner Online - Realistic 3D Money Washing Simulator</title>
    <meta name="description" content="Experience the ultimate ASMR money washing simulator. Clean dirty bills in a realistic 3D basement environment. Play Cash Cleaner Online for free now!">
    <meta name="keywords" content="cash cleaner, money washing game, asmr simulator, unblocked games, cash cleaner online, money cleaner, satisfying game, asmr game, 3d cleaning simulator">
    <meta name="author" content="Cash Cleaner Online">
    <link rel="canonical" href="https://cashcleaner.online/">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
    <meta property="og:title" content="Cash Cleaner Online - Realistic 3D Money Washing Simulator">
    <meta property="og:description" content="Experience the ultimate ASMR money washing simulator. Clean dirty bills in a realistic 3D basement environment. Play for free now!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cashcleaner.online/">
    
    <!-- TWEEN.js for smooth camera transitions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Fullscreen Canvas */
        canvas {
            position: fixed;
            inset: 0;
            display: block;
        }

        /* Score Board HUD */
        #score-board {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 15px 25px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            line-height: 1.4;
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            z-index: 1000;
            user-select: none;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #score-board .label {
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            margin-bottom: 5px;
        }

        /* Mode & Tool UI */
        #mode-tool-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

        #mode-tool-ui .section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        #mode-tool-ui .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        #mode-tool-ui .label {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.6);
            margin-bottom: 5px;
        }

        #mode-tool-ui .value {
            font-size: 16px;
            font-weight: bold;
        }

        #mode-tool-ui .btn {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: all 0.2s;
        }

        #mode-tool-ui .btn:hover:not(.disabled) {
            background: rgba(0, 255, 136, 0.4);
        }

        #mode-tool-ui .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: #666;
            border-color: #666;
        }

        /* Debug HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            z-index: 1000;
            user-select: none;
        }

        #hud div {
            margin: 2px 0;
        }

        /* SEO Overlay */
        #seoOverlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            max-height: 50vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: #ffffff;
            z-index: 900;
            transition: transform 0.3s ease;
        }

        #seoOverlay.hidden {
            transform: translateY(100%);
        }

        #seoToggle {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            z-index: 901;
            user-select: none;
        }

        #seoToggle:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        #content {
            width: 100%;
            max-width: 900px;
            padding: 40px 20px;
            margin: 0 auto;
            line-height: 1.8;
            user-select: text;
        }

        #content h2 {
            color: #00ff88;
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #content h2:first-child {
            margin-top: 0;
        }

        #content p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 15px;
            margin-bottom: 15px;
            text-align: justify;
        }

        #adBottom {
            text-align: center;
            padding: 30px 0;
            background: rgba(0, 0, 0, 0.8);
        }

        footer {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        footer a {
            color: #00ff88;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Collect Feedback */
        #collectFeedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #00ff88, #00cc66);
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #111;
            z-index: 2000;
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        #collectFeedback.show {
            transform: translate(-50%, -50%) scale(1);
        }

        /* Back Button (Focus View) */
        #backButton {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 2000;
            transition: all 0.3s;
            display: none;
        }

        #backButton:hover {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(1.05);
        }

        #backButton.show {
            display: block;
        }

        /* SEO H1 - Visually hidden but accessible */
        #seo-h1 {
            position: absolute;
            left: -10000px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            #content {
                padding: 30px 15px;
            }
            #content h2 {
                font-size: 20px;
            }
            #content p {
                font-size: 14px;
            }
            #hud {
                font-size: 10px;
                padding: 8px;
            }
            #score-board {
                font-size: 18px;
                padding: 12px 20px;
            }
            #score-board .label {
                font-size: 12px;
            }
            #mode-tool-ui {
                font-size: 12px;
                padding: 10px;
            }
            #mode-tool-ui .value {
                font-size: 14px;
            }
            #mode-tool-ui .btn {
                font-size: 11px;
                padding: 5px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- SEO H1 (visually hidden for accessibility) -->
    <h1 id="seo-h1">Cash Cleaner Online - The Best 3D Cleaning Simulator</h1>

    <!-- Score Board -->
    <div id="score-board">
        <div class="label">CLEANED</div>
        <div id="scoreAmount">$0</div>
    </div>

    <!-- Mode & Tool UI -->
    <div id="mode-tool-ui">
        <div class="section">
            <div class="label">MODE (SPACE)</div>
            <div class="value" id="currentMode">HAND</div>
        </div>
        <div class="section">
            <div class="label">CURRENT TOOL</div>
            <div class="value" id="currentTool">Eraser</div>
        </div>
        <div class="section">
            <div class="label">SHOP</div>
            <button class="btn" id="buyBrushBtn" onclick="buyBrush()">Buy Brush $500</button>
        </div>
        <div class="section">
            <div class="label">BOX MONEY</div>
            <div class="value" id="boxMoneyCount">30</div>
        </div>
    </div>

    <!-- Debug HUD -->
    <div id="hud" style="display:none;">
        <div>FPS: <span id="fps">0</span></div>
        <div>Cleaned: <span id="cleanedCount">0</span></div>
        <div>Camera: <span id="camPos">0,0,0</span></div>
        <div>Exposure: <span id="exposure">1.25</span></div>
        <div style="margin-top:8px;color:#888">H: Info | L/K: Exposure | R: Reset Cam</div>
    </div>

    <!-- Collect Feedback -->
    <div id="collectFeedback">+$100</div>

    <!-- Back Button (Focus View) -->
    <button id="backButton" onclick="returnToGlobalView()">‚Üê Back to Overview</button>

    <!-- SEO Overlay Toggle -->
    <div id="seoToggle" onclick="toggleSEO()">Press H for Info</div>

    <!-- SEO Content Overlay -->
    <div id="seoOverlay" class="hidden">
        <section id="content">
            <h2>What is Cash Cleaner Online?</h2>
            <p>Cash Cleaner Online is a free-to-play browser-based cleaning simulator that brings the viral ASMR satisfaction of power washing directly to your screen. The game recreates the oddly satisfying experience of using a high-pressure washer to clean dirty money, gold bars, and credit cards. Unlike traditional mobile apps that require downloads and installations, this web version is instantly accessible from any device with a browser.</p>
            <p>The gameplay is elegantly simple yet deeply engaging. Players are presented with various valuable items covered in layers of realistic dirt and grime. Using your mouse or finger as a virtual pressure washer, you drag across the screen to blast away the accumulated muck. As you clean, water spray particles animate in real-time, creating a mesmerizing visual effect that mimics actual cleaning physics. The dirt erodes gradually under your cursor, revealing the pristine surface beneath.</p>
            <p>What sets Cash Cleaner Online apart is its progressive reward system. Each successfully cleaned item grants you virtual earnings - from $100 for standard bills to $1000 for platinum cards. The game continuously generates new dirty items to maintain an endless loop of satisfaction. This creates what psychologists call a "flow state" - that perfect balance between challenge and reward that keeps players engaged for extended sessions. The visual feedback is immediate and gratifying, with confetti explosions and glowing animations celebrating each completed cleaning.</p>
            <p>The game has gained massive popularity in online communities, schools, and workplaces because it's completely unblocked and requires no permissions. It's the perfect stress-relief tool during breaks, offering a few minutes of mindless zen without any learning curve or complex mechanics. The dark aesthetic makes the bright money pop visually, creating strong contrast that's both aesthetically pleasing and easy on the eyes during extended play sessions.</p>

            <h2>Why Cash Cleaning Games Are So Satisfying</h2>
            <p>The phenomenon of cleaning games taps into deep psychological mechanisms that explain why millions of players find them irresistibly satisfying. At its core, the appeal lies in our brain's reward system responding to visible progress and completion. When you see dirt disappearing under your cursor in real-time, your brain releases small doses of dopamine - the same neurotransmitter associated with achievement and pleasure. This is why power washing videos have garnered billions of views across social media platforms.</p>
            <p>ASMR (Autonomous Sensory Meridian Response) plays a significant role in the appeal of cleaning simulators. While Cash Cleaner Online doesn't include sound, the visual ASMR effect is equally powerful. The gradual transformation from dirty to clean creates a sense of order emerging from chaos, which resonates with our innate desire for control and organization. This visual satisfaction is amplified by the particle effects that simulate water spray, triggering the same neural pathways activated by watching real cleaning processes.</p>
            <p>From a cognitive psychology perspective, these games offer what researchers call "productive procrastination." They provide a sense of accomplishment without real-world consequences or stress. In today's high-pressure environment where complex tasks can feel overwhelming, the simple binary outcome of dirty-to-clean offers clarity and immediate gratification. Each swipe produces visible results, creating a micro-achievement loop that's incredibly addictive.</p>
            <p>The repetitive nature of the cleaning motion also has meditative qualities. Similar to how coloring books have become popular stress-relief tools for adults, the rhythmic dragging motion required in Cash Cleaner Online creates a focused, almost trance-like state. This repetition can lower cortisol levels and reduce anxiety, making these games unexpectedly therapeutic. Players report feeling calmer and more centered after playing, which explains why cleaning simulators have become popular during work breaks and before sleep.</p>

            <h2>How to Play Cash Cleaner Online</h2>
            <p>Getting started with Cash Cleaner Online is incredibly straightforward - there's virtually no learning curve. Simply load the page and you'll immediately see a dirty bill displayed in the center of your screen. The dirt layer is represented by a dark, gritty overlay that completely obscures the clean money beneath.</p>
            <p>On desktop computers, use your mouse to click and drag across the dirty surface. On mobile devices and tablets, use your finger to swipe across the screen. As you move your cursor or finger, the high-pressure washer effect kicks in, erasing the dirt layer and revealing the pristine surface underneath. The larger your movements, the faster you'll clean. The game tracks your progress in real-time via a progress bar at the top of the screen, showing the percentage of dirt removed.</p>
            <p>Your goal is to reach 95% cleanliness. Once you hit this threshold, the game celebrates your achievement with a spectacular confetti explosion and displays your earned reward. After a brief celebration animation, a new dirty item automatically appears - either another dollar bill, a gold bar, or a platinum credit card. Each item type has slightly different textures and colors, keeping the visual experience fresh.</p>
            <p>The beauty of Cash Cleaner Online is that there's no wrong way to play. Some players prefer methodical horizontal strokes, others use circular motions, and some just frantically scrub random areas. All approaches work equally well. The game is designed for instant satisfaction - you can complete a single cleaning cycle in under 60 seconds, making it perfect for quick breaks or extended relaxation sessions alike.</p>

            <h2>Is Cash Cleaner Online Free?</h2>
            <p>Yes, Cash Cleaner Online is completely free to play with absolutely no hidden costs or microtransactions. There's no premium version, no in-app purchases, no subscription fees, and no advertisements interrupting your gameplay. The game was designed as a pure entertainment experience without monetization mechanics that would detract from the core satisfaction loop.</p>
            <p>You don't need to create an account, provide an email address, or download any software. Simply visit the website and start playing immediately. This accessibility is intentional - the goal is to provide instant stress relief without any barriers to entry. The game works on all modern browsers including Chrome, Firefox, Safari, and Edge, across all device types from smartphones to desktop computers.</p>
            <p>Because the game runs entirely in your browser using HTML5 technology, there are no storage requirements on your device and no permissions needed. Your progress isn't saved between sessions, which is actually a feature rather than a limitation - it means each visit offers a fresh start without the pressure of maintaining streaks or achievements. This design philosophy keeps the experience pure and meditative, focused solely on the immediate satisfaction of cleaning rather than long-term progression systems that can create addictive patterns.</p>
            <p>The game is also completely unblocked, meaning it works on school networks, office wifi, and other restricted internet connections that typically block gaming sites. This has made Cash Cleaner Online particularly popular among students looking for quick study breaks and office workers seeking momentary stress relief during busy workdays.</p>
        </section>

        <div id="adBottom">
            <script>
              atOptions = {
                'key' : 'ec8c5f314722aa8c54e18afcf25d60c7',
                'format' : 'iframe',
                'height' : 90,
                'width' : 728,
                'params' : {}
              };
            </script>
            <script src="https://offeringmakeup.com/ec8c5f314722aa8c54e18afcf25d60c7/invoke.js"></script>
        </div>

        <footer>
            <a href="/privacy.html">Privacy Policy</a> |
            <a href="/terms.html">Terms of Service</a> |
            <a href="/about.html">About Us</a> |
            <a href="/contact.html">Contact</a>
        </footer>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';

        // ===== Global State =====
        let scene, camera, renderer, controls;
        let bills = [];
        let cashBoxOnTable = null;
        let cashBoxOnFloor = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-999, -999);
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        // Interaction state
        let hoveredBill = null;
        let selectedBill = null;
        let totalScore = 0;
        let cleanedCount = 0;
        let boxMoneyCount = 30;

        // Mode & Tool system
        let currentMode = 'HAND'; // 'HAND' or 'TOOL'
        let currentTool = 'Eraser'; // 'Eraser' or 'Brush'
        let toolRadius = { Eraser: 20, Brush: 60 }; // Canvas brush sizes
        let ownedTools = ['Eraser'];
        const toolPrices = { Brush: 500 };

        // Camera View States
        let cameraView = 'GLOBAL'; // 'GLOBAL' or 'FOCUS'
        const CAMERA_STATES = {
            GLOBAL: {
                position: { x: 0, y: 4, z: 5 },
                target: { x: 0, y: 1.1, z: 0 }
            },
            FOCUS: {
                position: { x: 0, y: 2.5, z: 0 },
                target: { x: 0, y: 1.05, z: 0 }
            }
        };
        let workTableLight = null; // Dedicated work light for focus view

        // Cleaning state
        let isCleaning = false;

        // Audio system
        let audioContext;
        let isAudioInitialized = false;

        // Scene dimensions (computed from geometry)
        const roomDimensions = { width: 12, height: 6, depth: 12 };
        const tableDimensions = { width: 3, height: 0.1, depth: 2, posY: 1 };
        const floorY = 0;
        const collisionMargin = 0.3;

        // ===== Init =====
        function init() {
            createScene();
            createLights();
            createRoom();
            createTable();
            createCashBoxes();
            createProps();
            loadBillTexture();
            bindInput();
            initAudio();
            animate();
        }

        // ===== Audio System =====
        function initAudio() {
            // Lazy init on first user interaction
            document.addEventListener('click', () => {
                if (!isAudioInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    isAudioInitialized = true;
                    console.log('Audio initialized');
                }
            }, { once: true });
        }

        function playCollectSound() {
            if (!isAudioInitialized) return;
            
            // Create pleasant collection sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // ===== Scene Setup =====
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 8, 20);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 4, 5);
            camera.lookAt(0, 1.1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.physicallyCorrectLights = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.enablePan = false;
            controls.rotateSpeed = 0.9;
            controls.zoomSpeed = 0.9;
            controls.minDistance = 2.6;
            controls.maxDistance = 7.0;
            controls.minPolarAngle = Math.PI * 0.18;
            controls.maxPolarAngle = Math.PI * 0.48;
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        // ===== Lights =====
        function createLights() {
            // Ambient light - cool tone, weak
            const ambientLight = new THREE.AmbientLight(0x6688bb, 0.3);
            scene.add(ambientLight);

            // Hemisphere light - cool top, warm ground
            const hemiLight = new THREE.HemisphereLight(0x5577cc, 0x664422, 0.5);
            scene.add(hemiLight);

            // Main spotlight from ceiling
            const spotLight = new THREE.SpotLight(0xfffff0, 120);
            spotLight.position.set(0, 5.5, 0.5);
            spotLight.target.position.set(0, 1, 0);
            spotLight.angle = Math.PI / 4.5;
            spotLight.penumbra = 0.4;
            spotLight.decay = 2;
            spotLight.distance = 10;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 10;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);
            scene.add(spotLight.target);

            // RectAreaLight - key fill light from side-front
            const rectLight = new THREE.RectAreaLight(0xffffff, 4, 3, 2);
            rectLight.position.set(2, 2, 3);
            rectLight.lookAt(0, 1, 0);
            scene.add(rectLight);

            // Additional soft fill from opposite side
            const fillLight = new THREE.PointLight(0xaabbcc, 0.8, 8);
            fillLight.position.set(-2, 2.5, 2);
            scene.add(fillLight);

            // Work table light for focus view (initially off)
            workTableLight = new THREE.PointLight(0xffffff, 0, 5);
            workTableLight.position.set(0, 2, 0);
            scene.add(workTableLight);
        }

        // ===== Room =====
        function createRoom() {
            // Inverted box for basement room - backside normals
            const roomGeo = new THREE.BoxGeometry(12, 6, 12);
            const roomMat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                side: THREE.BackSide,
                roughness: 0.9,
                metalness: 0.05
            });
            const room = new THREE.Mesh(roomGeo, roomMat);
            room.position.y = 3;
            room.receiveShadow = true;
            scene.add(room);

            // Floor with slight reflectivity
            const floorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x424242,
                roughness: 0.7,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        // ===== Table =====
        function createTable() {
            // Deep aged oak wood material
            const tableMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817, // Deep aged oak
                roughness: 0.88,
                metalness: 0.05,
                roughnessMap: createWoodRoughnessMap()
            });

            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 2),
                tableMat
            );
            tableTop.position.set(0, 1, 0);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            scene.add(tableTop);

            const legGeo = new THREE.BoxGeometry(0.1, 0.9, 0.1);
            const positions = [
                [-1.3, 0.45, -0.85],
                [1.3, 0.45, -0.85],
                [-1.3, 0.45, 0.85],
                [1.3, 0.45, 0.85]
            ];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });
        }

        function createWoodRoughnessMap() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base wood color with grain
            for (let y = 0; y < size; y++) {
                const grainIntensity = Math.sin(y * 0.15) * 25 + 110;
                ctx.fillStyle = `rgb(${grainIntensity},${grainIntensity},${grainIntensity})`;
                ctx.fillRect(0, y, size, 1);
            }
            
            // Add noise variation and scratches
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 40;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = data[i];
                data[i+2] = data[i];
            }
            
            // Add random scratches
            ctx.putImageData(imageData, 0, 0);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * size, Math.random() * size);
                ctx.lineTo(Math.random() * size, Math.random() * size);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            return texture;
        }

        // ===== Cash Boxes =====
        function createCashBoxes() {
            const boxMat = new THREE.MeshStandardMaterial({
                color: 0x8b6f47,
                roughness: 0.8,
                metalness: 0.1
            });

            // Cash box on table
            cashBoxOnTable = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.15, 0.3),
                boxMat
            );
            cashBoxOnTable.position.set(0.9, 1.125, 0);
            cashBoxOnTable.castShadow = true;
            cashBoxOnTable.receiveShadow = true;
            cashBoxOnTable.userData = { type: 'cashBox', interactable: true };
            scene.add(cashBoxOnTable);

            // Cash box on floor (decoration)
            cashBoxOnFloor = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.4, 0.4),
                boxMat
            );
            cashBoxOnFloor.position.set(2, 0.2, -1.5);
            cashBoxOnFloor.rotation.y = 0.3;
            cashBoxOnFloor.castShadow = true;
            cashBoxOnFloor.receiveShadow = true;
            scene.add(cashBoxOnFloor);

            console.log('Cash boxes created');
        }

        // ===== Room Props =====
        function createProps() {
            // Crate in corner
            const crateMat = new THREE.MeshStandardMaterial({
                color: 0x5a4a3a,
                roughness: 0.9,
                metalness: 0.0
            });
            const crate = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), crateMat);
            crate.position.set(-4, 0.4, -4);
            crate.rotation.y = 0.3;
            crate.castShadow = true;
            crate.receiveShadow = true;
            scene.add(crate);

            // Pipes along wall
            const pipeMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.4,
                metalness: 0.6
            });
            const pipe1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4, 8), pipeMat);
            pipe1.position.set(-5.9, 1.5, 0);
            pipe1.rotation.z = Math.PI / 2;
            pipe1.castShadow = true;
            scene.add(pipe1);

            // Neon strip light
            const neonGeo = new THREE.BoxGeometry(2, 0.05, 0.05);
            const neonMat = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 2,
                roughness: 0.2,
                metalness: 0.8
            });
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.position.set(3, 2.5, -5.9);
            scene.add(neon);

            // Add small point light for neon
            const neonLight = new THREE.PointLight(0x00ff88, 0.5, 3);
            neonLight.position.copy(neon.position);
            scene.add(neonLight);
        }

        // ===== Bill Class (Scratch Card System) =====
        let billBaseTexture = null;

        class Bill {
            constructor(x, y, z) {
                this.cleanProgress = 0;
                this.isDirty = true;
                this.value = 100;
                this.baseY = y;
                
                // Create dirt canvas (512x256 for 2:1 ratio)
                this.dirtCanvas = document.createElement('canvas');
                this.dirtCanvas.width = 512;
                this.dirtCanvas.height = 256;
                this.dirtCtx = this.dirtCanvas.getContext('2d');
                
                // Fill with dirty brown noise
                this.createDirtLayer();
                
                // Create dirt texture
                this.dirtTexture = new THREE.CanvasTexture(this.dirtCanvas);
                this.dirtTexture.needsUpdate = true;
                
                // Create geometry
                const geometry = new THREE.PlaneGeometry(0.3, 0.15);
                
                // Create material with base texture and dirt overlay
                const material = new THREE.MeshStandardMaterial({
                    map: billBaseTexture,
                    alphaMap: this.dirtTexture,
                    transparent: true,
                    roughness: 0.6,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Create mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, y, z);
                this.mesh.rotation.set(-Math.PI / 2, Math.random() * Math.PI * 2, 0);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                
                // Link back to this Bill instance
                this.mesh.userData.billInstance = this;
            }
            
            createDirtLayer() {
                const ctx = this.dirtCtx;
                const w = this.dirtCanvas.width;
                const h = this.dirtCanvas.height;
                
                // Fill with dark brown dirt
                ctx.fillStyle = '#2a1a0f';
                ctx.fillRect(0, 0, w, h);
                
                // Add noise/texture
                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const noise = Math.random() * 60 - 30;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
                    data[i + 3] = 255; // Full opacity (dirty)
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Add some darker spots for extra dirt
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const radius = 20 + Math.random() * 40;
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, 'rgba(20, 10, 5, 0.6)');
                    gradient.addColorStop(1, 'rgba(20, 10, 5, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
                }
            }
            
            // Erase dirt at UV coordinates
            erase(uv, brushSize) {
                const ctx = this.dirtCtx;
                const x = uv.x * this.dirtCanvas.width;
                const y = (1 - uv.y) * this.dirtCanvas.height;
                
                // Use destination-out to make transparent (scratch card effect)
                ctx.globalCompositeOperation = 'destination-out';
                
                // Draw soft-edged circle
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, brushSize);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
                
                // Mark texture for update
                this.dirtTexture.needsUpdate = true;
            }
            
            // Calculate clean progress (percentage of transparent pixels)
            calculateProgress() {
                const imageData = this.dirtCtx.getImageData(
                    0, 0, 
                    this.dirtCanvas.width, 
                    this.dirtCanvas.height
                );
                const data = imageData.data;
                
                let transparentPixels = 0;
                const totalPixels = this.dirtCanvas.width * this.dirtCanvas.height;
                
                // Check alpha channel (every 4th value)
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] < 128) { // Mostly transparent
                        transparentPixels++;
                    }
                }
                
                this.cleanProgress = transparentPixels / totalPixels;
                return this.cleanProgress;
            }
            
            // Clean up resources
            dispose() {
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
                if (this.dirtTexture) this.dirtTexture.dispose();
                this.dirtCanvas = null;
                this.dirtCtx = null;
            }
        }

        // Load base bill texture
        function loadBillTexture() {
            const loader = new THREE.TextureLoader();
            
            loader.load(
                'https://upload.wikimedia.org/wikipedia/commons/7/7b/United_States_one_dollar_bill_obverse.jpg',
                (texture) => {
                    console.log('Bill texture loaded successfully');
                    billBaseTexture = texture;
                },
                undefined,
                (error) => {
                    console.warn('Failed to load bill texture, using fallback', error);
                    // Create fallback green texture
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#85bb65';
                    ctx.fillRect(0, 0, 512, 256);
                    billBaseTexture = new THREE.CanvasTexture(canvas);
                }
            );
        }

        // Spawn new bill from box
        function spawnBillFromBox() {
            if (boxMoneyCount <= 0) {
                console.log('Box is empty!');
                return;
            }

            // Random position on table
            const randomX = (Math.random() - 0.5) * 1.5;
            const randomZ = (Math.random() - 0.5) * 1.0;
            const randomY = 1.055 + Math.random() * 0.01;
            
            // Create new bill
            const bill = new Bill(randomX, randomY, randomZ);
            bills.push(bill);
            scene.add(bill.mesh);
            
            boxMoneyCount--;
            updateUI();
            
            console.log(`Spawned bill from box. Remaining: ${boxMoneyCount}`);
        }

        // ===== Interaction System =====
        function updateInteraction() {
            raycaster.setFromCamera(mouse, camera);
            
            if (currentMode === 'HAND') {
                // Check for cash box hover
                const boxIntersects = raycaster.intersectObjects([cashBoxOnTable], false);
                
                if (boxIntersects.length > 0) {
                    // Highlight cash box
                    cashBoxOnTable.material.emissive = new THREE.Color(0x00ff88);
                    cashBoxOnTable.material.emissiveIntensity = 0.3;
                } else {
                    cashBoxOnTable.material.emissive = new THREE.Color(0x000000);
                    cashBoxOnTable.material.emissiveIntensity = 0;
                }
            } else if (currentMode === 'TOOL') {
                // Get bill meshes for raycasting
                const billMeshes = bills.map(b => b.mesh);
                const billIntersects = raycaster.intersectObjects(billMeshes, false);
                
                // Reset previously hovered bill
                if (hoveredBill && (billIntersects.length === 0 || billIntersects[0].object !== hoveredBill)) {
                    const billInstance = hoveredBill.userData.billInstance;
                    if (billInstance) {
                        hoveredBill.position.y = billInstance.baseY;
                    }
                    hoveredBill = null;
                }
                
                // Apply hover effect to current bill
                if (billIntersects.length > 0) {
                    const billMesh = billIntersects[0].object;
                    if (billMesh !== hoveredBill) {
                        hoveredBill = billMesh;
                    }
                    
                    const billInstance = hoveredBill.userData.billInstance;
                    if (billInstance) {
                        // Subtle lift for cleaning target
                        hoveredBill.position.y = billInstance.baseY + 0.01;
                    }
                }
            }
        }

        function cleanAtPoint(intersection) {
            const billMesh = intersection.object;
            const uv = intersection.uv;
            const billInstance = billMesh.userData.billInstance;
            
            if (!uv || !billInstance) return;

            // Get brush size based on current tool
            const brushSize = toolRadius[currentTool];
            
            // Erase dirt at UV coordinates
            billInstance.erase(uv, brushSize);
            
            // Update progress
            billInstance.calculateProgress();
            
            // Check if cleaning is complete
            if (billInstance.cleanProgress >= 0.95 && billInstance.isDirty) {
                billInstance.isDirty = false;
                completeBillCleaning(billInstance);
            }
        }

        function completeBillCleaning(billInstance) {
            if (!billInstance) return;
            
            const billMesh = billInstance.mesh;
            
            // Animate bill collection
            const duration = 300;
            const startTime = performance.now();
            
            function animateCollect() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const scale = 1 - progress;
                billMesh.scale.set(scale, scale, scale);
                billMesh.rotation.y += 0.2;
                
                if (progress < 1) {
                    requestAnimationFrame(animateCollect);
                } else {
                    scene.remove(billMesh);
                    bills = bills.filter(b => b !== billInstance);
                    billInstance.dispose();
                    
                    console.log(`Bill cleaned! Remaining: ${bills.length}`);
                }
            }
            
            animateCollect();
            
            const value = billInstance.value || 100;
            totalScore += value;
            cleanedCount++;
            updateUI();
            showCollectFeedback(value);
            playCollectSound();
        }

        function updateUI() {
            document.getElementById('scoreAmount').textContent = '$' + totalScore;
            document.getElementById('cleanedCount').textContent = cleanedCount;
            document.getElementById('currentMode').textContent = currentMode;
            document.getElementById('currentTool').textContent = currentTool;
            document.getElementById('boxMoneyCount').textContent = boxMoneyCount;
            
            // Update buy button state
            const buyBtn = document.getElementById('buyBrushBtn');
            if (ownedTools.includes('Brush')) {
                buyBtn.textContent = 'Brush Owned';
                buyBtn.classList.add('disabled');
            } else if (totalScore >= toolPrices.Brush) {
                buyBtn.classList.remove('disabled');
            }
        }

        // ===== Camera View Transitions =====
        function switchToFocusView() {
            if (cameraView === 'FOCUS') return;
            
            cameraView = 'FOCUS';
            const target = CAMERA_STATES.FOCUS;
            
            // Disable orbit controls during transition
            controls.enabled = false;
            
            // Animate camera position
            new TWEEN.Tween(camera.position)
                .to(target.position, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
            
            // Animate camera target
            new TWEEN.Tween(controls.target)
                .to(target.target, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => {
                    controls.update();
                })
                .onComplete(() => {
                    // Keep controls disabled in focus view
                    controls.enabled = false;
                    
                    // Show back button
                    document.getElementById('backButton').classList.add('show');
                    
                    // Hide mode-tool UI
                    document.getElementById('mode-tool-ui').style.display = 'none';
                    
                    // Turn on work table light
                    new TWEEN.Tween(workTableLight)
                        .to({ intensity: 3 }, 500)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();
                    
                    // Auto switch to TOOL mode
                    if (currentMode !== 'TOOL') {
                        currentMode = 'TOOL';
                        updateUI();
                    }
                })
                .start();
        }

        function returnToGlobalView() {
            if (cameraView === 'GLOBAL') return;
            
            cameraView = 'GLOBAL';
            const target = CAMERA_STATES.GLOBAL;
            
            // Turn off work table light
            new TWEEN.Tween(workTableLight)
                .to({ intensity: 0 }, 500)
                .easing(TWEEN.Easing.Quadratic.In)
                .start();
            
            // Hide back button
            document.getElementById('backButton').classList.remove('show');
            
            // Show mode-tool UI
            document.getElementById('mode-tool-ui').style.display = 'block';
            
            // Animate camera position
            new TWEEN.Tween(camera.position)
                .to(target.position, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
            
            // Animate camera target
            new TWEEN.Tween(controls.target)
                .to(target.target, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => {
                    controls.update();
                })
                .onComplete(() => {
                    // Re-enable orbit controls
                    controls.enabled = true;
                    
                    // Switch back to HAND mode
                    currentMode = 'HAND';
                    updateUI();
                })
                .start();
        }

        window.returnToGlobalView = returnToGlobalView;

        function showCollectFeedback(value) {
            const feedback = document.getElementById('collectFeedback');
            feedback.textContent = '+$' + value;
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 500);
        }

        function toggleMode() {
            currentMode = currentMode === 'HAND' ? 'TOOL' : 'HAND';
            updateUI();
            console.log('Mode switched to:', currentMode);
        }

        window.buyBrush = function() {
            if (ownedTools.includes('Brush')) {
                console.log('Already owned');
                return;
            }
            
            if (totalScore >= toolPrices.Brush) {
                totalScore -= toolPrices.Brush;
                ownedTools.push('Brush');
                currentTool = 'Brush';
                updateUI();
                playCollectSound();
                console.log('Brush purchased!');
            } else {
                console.log('Not enough money. Need $' + toolPrices.Brush);
            }
        }

        // ===== Input =====
        function bindInput() {
            window.addEventListener('resize', onResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // Left click only
            
            if (currentMode === 'HAND') {
                raycaster.setFromCamera(mouse, camera);
                const boxIntersects = raycaster.intersectObjects([cashBoxOnTable], false);
                
                if (boxIntersects.length > 0) {
                    if (cameraView === 'GLOBAL') {
                        // Switch to focus view first
                        switchToFocusView();
                        // Spawn bill after camera transition
                        setTimeout(() => {
                            spawnBillFromBox();
                        }, 1500);
                    } else {
                        // Already in focus view, just spawn
                        spawnBillFromBox();
                    }
                }
            } else if (currentMode === 'TOOL') {
                // Start cleaning (only works in focus view)
                raycaster.setFromCamera(mouse, camera);
                const billMeshes = bills.map(b => b.mesh);
                const billIntersects = raycaster.intersectObjects(billMeshes, false);
                
                if (billIntersects.length > 0) {
                    isCleaning = true;
                    selectedBill = billIntersects[0].object;
                    cleanAtPoint(billIntersects[0]);
                    // No need to disable controls - already disabled in focus view
                }
            }
        }

        function onMouseUp(event) {
            if (isCleaning) {
                isCleaning = false;
                selectedBill = null;
                controls.enabled = true;
            }
        }

        function onMouseMove(event) {
            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Continue cleaning if mouse is down in TOOL mode
            if (isCleaning && selectedBill) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([selectedBill], false);
                if (intersects.length > 0) {
                    cleanAtPoint(intersects[0]);
                }
            }
        }

        // ===== Camera Clamping =====
        function clampCamera() {
            const pos = camera.position;
            
            // 1. Floor constraint
            if (pos.y < floorY + collisionMargin) {
                pos.y = floorY + collisionMargin;
            }
            
            // 2. Room boundary constraints
            const roomHalfX = roomDimensions.width / 2 - collisionMargin;
            const roomHalfZ = roomDimensions.depth / 2 - collisionMargin;
            
            pos.x = THREE.MathUtils.clamp(pos.x, -roomHalfX, roomHalfX);
            pos.z = THREE.MathUtils.clamp(pos.z, -roomHalfZ, roomHalfZ);
            
            // 3. Table collision (Box3 check)
            const tableBox = new THREE.Box3(
                new THREE.Vector3(
                    -tableDimensions.width / 2 - collisionMargin,
                    tableDimensions.posY - tableDimensions.height / 2 - collisionMargin,
                    -tableDimensions.depth / 2 - collisionMargin
                ),
                new THREE.Vector3(
                    tableDimensions.width / 2 + collisionMargin,
                    tableDimensions.posY + tableDimensions.height / 2 + collisionMargin,
                    tableDimensions.depth / 2 + collisionMargin
                )
            );
            
            if (tableBox.containsPoint(pos)) {
                // Push camera out from table center
                const tableCenter = new THREE.Vector3(0, tableDimensions.posY, 0);
                const pushDir = pos.clone().sub(tableCenter).normalize();
                
                // Find closest point on box boundary
                const closestPoint = tableBox.clampPoint(pos, new THREE.Vector3());
                const pushDistance = collisionMargin * 1.5;
                
                pos.copy(closestPoint).add(pushDir.multiplyScalar(pushDistance));
                
                // Update controls distance if needed
                const distToTarget = pos.distanceTo(controls.target);
                if (distToTarget < controls.minDistance) {
                    controls.minDistance = distToTarget + 0.1;
                }
            }
        }

        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case ' ':
                    event.preventDefault();
                    toggleMode();
                    break;
                case 'h':
                    toggleSEO();
                    const hud = document.getElementById('hud');
                    hud.style.display = hud.style.display === 'none' ? 'block' : 'none';
                    break;
                case 'l':
                    renderer.toneMappingExposure = Math.min(3, renderer.toneMappingExposure + 0.1);
                    updateHUD();
                    break;
                case 'k':
                    renderer.toneMappingExposure = Math.max(0.5, renderer.toneMappingExposure - 0.1);
                    updateHUD();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case '1':
                    if (ownedTools.includes('Eraser')) {
                        currentTool = 'Eraser';
                        updateUI();
                    }
                    break;
                case '2':
                    if (ownedTools.includes('Brush')) {
                        currentTool = 'Brush';
                        updateUI();
                    }
                    break;
            }
        }

        function resetCamera() {
            camera.position.set(0, 4, 5);
            controls.target.set(0, 1.1, 0);
            controls.update();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== Animation Loop =====
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = now - lastTime;
            lastTime = now;

            frameCount++;
            fpsTime += delta;
            if (fpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // Update TWEEN animations
            TWEEN.update();

            // Update interaction system
            updateInteraction();

            controls.update();
            clampCamera(); // Prevent camera clipping through objects
            updateHUD();
            renderer.render(scene, camera);
        }

        // ===== HUD =====
        function updateHUD() {
            const pos = camera.position;
            document.getElementById('camPos').textContent = 
                `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;
            document.getElementById('exposure').textContent = 
                renderer.toneMappingExposure.toFixed(2);
        }

        // ===== SEO Toggle =====
        window.toggleSEO = function() {
            document.getElementById('seoOverlay').classList.toggle('hidden');
        }

        // Start
        init();
        updateUI();
    </script>

    <script src="https://offeringmakeup.com/a0/2d/50/a02d50405ef0bdf0d4243259c7266ce6.js"></script>
</body>
</html>
